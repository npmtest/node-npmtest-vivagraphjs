{"/home/travis/build/npmtest/node-npmtest-vivagraphjs/test.js":"/* istanbul instrument in package npmtest_vivagraphjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/lib.npmtest_vivagraphjs.js":"/* istanbul instrument in package npmtest_vivagraphjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_vivagraphjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_vivagraphjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-vivagraphjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_vivagraphjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_vivagraphjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_vivagraphjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_vivagraphjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_vivagraphjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_vivagraphjs.__dirname + '/lib.npmtest_vivagraphjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/viva.js":"/**\r\n * This is an entry point for global namespace. If you want to use separate\r\n * modules individually - you are more than welcome to do so.\r\n */\r\n\r\nvar random = require('ngraph.random');\r\n\r\nvar Viva = {\r\n  lazyExtend: function() {\r\n    return require('ngraph.merge').apply(this, arguments);\r\n  },\r\n  randomIterator: function() {\r\n    return random.randomIterator.apply(random, arguments);\r\n  },\r\n  random: function() {\r\n    return random.random.apply(random, arguments);\r\n  },\r\n  events: require('ngraph.events')\r\n};\r\n\r\nViva.Graph = {\r\n  version: require('./version.js'),\r\n  graph: require('ngraph.graph'),\r\n\r\n  serializer: function() {\r\n    return {\r\n      loadFromJSON: require('ngraph.fromjson'),\r\n      storeToJSON: require('ngraph.tojson')\r\n    };\r\n  },\r\n\r\n  centrality: require('./Algorithms/centrality.js'),\r\n  operations: require('./Algorithms/operations.js'),\r\n\r\n  geom: function() {\r\n    return {\r\n      intersect: require('gintersect'),\r\n      intersectRect: require('./Utils/intersectRect.js')\r\n    };\r\n  },\r\n\r\n  webgl: require('./WebGL/webgl.js'),\r\n  webglInputEvents: require('./WebGL/webglInputEvents.js'),\r\n\r\n  generator: function() {\r\n    return require('ngraph.generators');\r\n  },\r\n\r\n  Input: {\r\n    domInputManager: require('./Input/domInputManager.js'),\r\n    webglInputManager: require('./Input/webglInputManager.js')\r\n  },\r\n\r\n  Utils: {\r\n    // TODO: move to Input\r\n    dragndrop: require('./Input/dragndrop.js'),\r\n    findElementPosition: require('./Utils/findElementPosition.js'),\r\n    timer: require('./Utils/timer.js'),\r\n    getDimension: require('./Utils/getDimensions.js'),\r\n    events: require('./Utils/backwardCompatibleEvents.js')\r\n  },\r\n\r\n  Layout: {\r\n    forceDirected: require('ngraph.forcelayout'),\r\n    constant: require('./Layout/constant.js')\r\n  },\r\n\r\n  View: {\r\n    // TODO: Move `webglXXX` out to webgl namespace\r\n    Texture: require('./WebGL/texture.js'),\r\n    // TODO: This should not be even exported\r\n    webglAtlas: require('./WebGL/webglAtlas.js'),\r\n    webglImageNodeProgram: require('./WebGL/webglImageNodeProgram.js'),\r\n    webglLinkProgram: require('./WebGL/webglLinkProgram.js'),\r\n    webglNodeProgram: require('./WebGL/webglNodeProgram.js'),\r\n    webglLine: require('./WebGL/webglLine.js'),\r\n    webglSquare: require('./WebGL/webglSquare.js'),\r\n    webglImage: require('./WebGL/webglImage.js'),\r\n    webglGraphics: require('./View/webglGraphics.js'),\r\n    // TODO: Deprecate this:\r\n    _webglUtil: {\r\n      parseColor: require('./WebGL/parseColor.js')\r\n    },\r\n\r\n    // TODO: move to svg namespace\r\n    svgGraphics: require('./View/svgGraphics.js'),\r\n\r\n    renderer: require('./View/renderer.js'),\r\n\r\n    // deprecated\r\n    cssGraphics: function() {\r\n      throw new Error('cssGraphics is deprecated. Please use older version of vivagraph (< 0.7) if you need it');\r\n    },\r\n\r\n    svgNodeFactory: function() {\r\n      throw new Error('svgNodeFactory is deprecated. Please use older version of vivagraph (< 0.7) if you need it');\r\n    },\r\n\r\n    community: function() {\r\n      throw new Error('community is deprecated. Please use vivagraph < 0.7 if you need it, or `https://github.com/anvaka/ngraph.slpa` module');\r\n    }\r\n  },\r\n\r\n  Rect: require('./Utils/rect.js'),\r\n\r\n  svg: require('simplesvg'),\r\n\r\n  // TODO: should be camelCase\r\n  BrowserInfo: require('./Utils/browserInfo.js')\r\n};\r\n\r\nmodule.exports = Viva;\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/version.js":"// todo: this should be generated at build time.\nmodule.exports = '0.8.1';\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Algorithms/centrality.js":"var centrality = require('ngraph.centrality');\n\nmodule.exports = centralityWrapper;\n\nfunction centralityWrapper() {\n  // TODO: This should not be a function\n  return {\n    betweennessCentrality: betweennessCentrality,\n    degreeCentrality: degreeCentrality\n  };\n}\n\nfunction betweennessCentrality(g) {\n  var betweenness = centrality.betweenness(g);\n  return toVivaGraphCentralityFormat(betweenness);\n}\n\nfunction degreeCentrality(g, kind) {\n  var degree = centrality.degree(g, kind);\n  return toVivaGraphCentralityFormat(degree);\n}\n\nfunction toVivaGraphCentralityFormat(centrality) {\n  return Object.keys(centrality).sort(byValue).map(toKeyValue);\n\n  function byValue(x, y) {\n    return centrality[y] - centrality[x];\n  }\n\n  function toKeyValue(key) {\n    return {\n      key: key,\n      value: centrality[key]\n    };\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Algorithms/operations.js":"/**\r\n * @fileOverview Contains collection of primitive operations under graph.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\r\nmodule.exports = operations;\r\n\r\nfunction operations() {\r\n\r\n    return {\r\n        /**\r\n         * Gets graph density, which is a ratio of actual number of edges to maximum\r\n         * number of edges. I.e. graph density 1 means all nodes are connected with each other with an edge.\r\n         * Density 0 - graph has no edges. Runtime: O(1)\r\n         * \r\n         * @param graph represents oriented graph structure.\r\n         * @param directed (optional boolean) represents if the graph should be treated as a directed graph.\r\n         * \r\n         * @returns density of the graph if graph has nodes. NaN otherwise. Returns density for undirected graph by default but returns density for directed graph if a boolean 'true' is passed along with the graph.\r\n         */\r\n        density : function (graph,directed) {\r\n            var nodes = graph.getNodesCount();\r\n            if (nodes === 0) {\r\n                return NaN;\r\n            }\r\n            if(directed){\r\n                return graph.getLinksCount() / (nodes * (nodes - 1));\r\n            } else {\r\n                return 2 * graph.getLinksCount() / (nodes * (nodes - 1));\r\n            }\r\n        }\r\n    };\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webgl.js":"/**\n * @fileOverview Utility functions for webgl rendering.\n *\n * @author Andrei Kashcha (aka anvaka) / http://anvaka.blogspot.com\n */\n\nmodule.exports = webgl;\n\nfunction webgl(gl) {\n\n  return {\n    createProgram: createProgram,\n    extendArray: extendArray,\n    copyArrayPart: copyArrayPart,\n    swapArrayPart: swapArrayPart,\n    getLocations: getLocations,\n    context: gl\n  };\n\n  function createShader(shaderText, type) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, shaderText);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      var msg = gl.getShaderInfoLog(shader);\n      window.alert(msg);\n      throw msg;\n    }\n\n    return shader;\n  }\n\n  function createProgram(vertexShaderSrc, fragmentShaderSrc) {\n    var program = gl.createProgram();\n    var vs = createShader(vertexShaderSrc, gl.VERTEX_SHADER);\n    var fs = createShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);\n\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      var msg = gl.getShaderInfoLog(program);\n      window.alert(msg);\n      throw msg;\n    }\n\n    return program;\n  }\n\n  function extendArray(buffer, itemsInBuffer, elementsPerItem) {\n    if ((itemsInBuffer + 1) * elementsPerItem > buffer.length) {\n      // Every time we run out of space create new array twice bigger.\n      // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n      var extendedArray = new Float32Array(buffer.length * elementsPerItem * 2);\n      extendedArray.set(buffer);\n\n      return extendedArray;\n    }\n\n    return buffer;\n  }\n\n  function getLocations(program, uniformOrAttributeNames) {\n    var foundLocations = {};\n    for (var i = 0; i < uniformOrAttributeNames.length; ++i) {\n      var name = uniformOrAttributeNames[i];\n      var location = -1;\n      if (name[0] === 'a' && name[1] === '_') {\n        location = gl.getAttribLocation(program, name);\n        if (location === -1) {\n          throw new Error(\"Program doesn't have required attribute: \" + name);\n        }\n\n        foundLocations[name.slice(2)] = location;\n      } else if (name[0] === 'u' && name[1] === '_') {\n        location = gl.getUniformLocation(program, name);\n        if (location === null) {\n          throw new Error(\"Program doesn't have required uniform: \" + name);\n        }\n\n        foundLocations[name.slice(2)] = location;\n      } else {\n        throw new Error(\"Couldn't figure out your intent. All uniforms should start with 'u_' prefix, and attributes with 'a_'\");\n      }\n    }\n\n    return foundLocations;\n  }\n}\n\nfunction copyArrayPart(array, to, from, elementsCount) {\n  for (var i = 0; i < elementsCount; ++i) {\n    array[to + i] = array[from + i];\n  }\n}\n\nfunction swapArrayPart(array, from, to, elementsCount) {\n  for (var i = 0; i < elementsCount; ++i) {\n    var tmp = array[from + i];\n    array[from + i] = array[to + i];\n    array[to + i] = tmp;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglInputEvents.js":"var documentEvents = require('../Utils/documentEvents.js');\n\nmodule.exports = webglInputEvents;\n\n/**\n * Monitors graph-related mouse input in webgl graphics and notifies subscribers.\n *\n * @param {Viva.Graph.View.webglGraphics} webglGraphics\n */\nfunction webglInputEvents(webglGraphics) {\n  if (webglGraphics.webglInputEvents) {\n    // Don't listen twice, if we are already attached to this graphics:\n    return webglGraphics.webglInputEvents;\n  }\n\n  var mouseCapturedNode = null,\n    mouseEnterCallback = [],\n    mouseLeaveCallback = [],\n    mouseDownCallback = [],\n    mouseUpCallback = [],\n    mouseMoveCallback = [],\n    clickCallback = [],\n    dblClickCallback = [],\n    prevSelectStart,\n    boundRect;\n\n  var root = webglGraphics.getGraphicsRoot();\n  startListen(root);\n\n  var api = {\n    mouseEnter: mouseEnter,\n    mouseLeave: mouseLeave,\n    mouseDown: mouseDown,\n    mouseUp: mouseUp,\n    mouseMove: mouseMove,\n    click: click,\n    dblClick: dblClick,\n    mouseCapture: mouseCapture,\n    releaseMouseCapture: releaseMouseCapture\n  };\n\n  // TODO I don't remember why this is needed:\n  webglGraphics.webglInputEvents = api;\n\n  return api;\n\n  function releaseMouseCapture() {\n    mouseCapturedNode = null;\n  }\n\n  function mouseCapture(node) {\n    mouseCapturedNode = node;\n  }\n\n  function dblClick(callback) {\n    if (typeof callback === 'function') {\n      dblClickCallback.push(callback);\n    }\n    return api;\n  }\n\n  function click(callback) {\n    if (typeof callback === 'function') {\n      clickCallback.push(callback);\n    }\n    return api;\n  }\n\n  function mouseMove(callback) {\n    if (typeof callback === 'function') {\n      mouseMoveCallback.push(callback);\n    }\n    return api;\n  }\n\n  function mouseUp(callback) {\n    if (typeof callback === 'function') {\n      mouseUpCallback.push(callback);\n    }\n    return api;\n  }\n\n  function mouseDown(callback) {\n    if (typeof callback === 'function') {\n      mouseDownCallback.push(callback);\n    }\n    return api;\n  }\n\n  function mouseLeave(callback) {\n    if (typeof callback === 'function') {\n      mouseLeaveCallback.push(callback);\n    }\n    return api;\n  }\n\n  function mouseEnter(callback) {\n    if (typeof callback === 'function') {\n      mouseEnterCallback.push(callback);\n    }\n    return api;\n  }\n\n  function preciseCheck(nodeUI, x, y) {\n    if (nodeUI && nodeUI.size) {\n      var pos = nodeUI.position,\n        half = nodeUI.size;\n\n      return pos.x - half < x && x < pos.x + half &&\n        pos.y - half < y && y < pos.y + half;\n    }\n\n    return true;\n  }\n\n  function getNodeAtClientPos(pos) {\n    return webglGraphics.getNodeAtClientPos(pos, preciseCheck);\n  }\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n  }\n\n  function handleDisabledEvent(e) {\n    stopPropagation(e);\n    return false;\n  }\n\n  function invoke(callbacksChain, args) {\n    var i, stopPropagation;\n    for (i = 0; i < callbacksChain.length; i += 1) {\n      stopPropagation = callbacksChain[i].apply(undefined, args);\n      if (stopPropagation) {\n        return true;\n      }\n    }\n  }\n\n  function startListen(root) {\n    var pos = {\n        x: 0,\n        y: 0\n      },\n      lastFound = null,\n      lastUpdate = 1,\n      lastClickTime = +new Date(),\n\n      handleMouseMove = function(e) {\n        invoke(mouseMoveCallback, [lastFound, e]);\n        pos.x = e.clientX;\n        pos.y = e.clientY;\n      },\n\n      handleMouseUp = function() {\n        documentEvents.off('mousemove', handleMouseMove);\n        documentEvents.off('mouseup', handleMouseUp);\n      },\n\n      updateBoundRect = function() {\n        boundRect = root.getBoundingClientRect();\n      };\n\n    window.addEventListener('resize', updateBoundRect);\n    updateBoundRect();\n\n    // mouse move inside container serves only to track mouse enter/leave events.\n    root.addEventListener('mousemove',\n      function(e) {\n        if (mouseCapturedNode) {\n          return;\n        }\n        if (lastUpdate++ % 7 === 0) {\n          // since there is no bullet proof method to detect resize\n          // event, we preemptively update the bounding rectangle\n          updateBoundRect();\n          lastUpdate = 1;\n        }\n        var cancelBubble = false,\n          node;\n\n        pos.x = e.clientX - boundRect.left;\n        pos.y = e.clientY - boundRect.top;\n\n        node = getNodeAtClientPos(pos);\n\n        if (node && lastFound !== node) {\n          lastFound = node;\n          cancelBubble = cancelBubble || invoke(mouseEnterCallback, [lastFound]);\n        } else if (node === null && lastFound !== node) {\n          cancelBubble = cancelBubble || invoke(mouseLeaveCallback, [lastFound]);\n          lastFound = null;\n        }\n\n        if (cancelBubble) {\n          stopPropagation(e);\n        }\n      });\n\n    root.addEventListener('mousedown',\n      function(e) {\n        var cancelBubble = false,\n          args;\n        updateBoundRect();\n        pos.x = e.clientX - boundRect.left;\n        pos.y = e.clientY - boundRect.top;\n\n        args = [getNodeAtClientPos(pos), e];\n        if (args[0]) {\n          cancelBubble = invoke(mouseDownCallback, args);\n          // we clicked on a node. Following drag should be handled on document events:\n          documentEvents.on('mousemove', handleMouseMove);\n          documentEvents.on('mouseup', handleMouseUp);\n\n          prevSelectStart = window.document.onselectstart;\n\n          window.document.onselectstart = handleDisabledEvent;\n\n          lastFound = args[0];\n        } else {\n          lastFound = null;\n        }\n        if (cancelBubble) {\n          stopPropagation(e);\n        }\n      });\n\n    root.addEventListener('mouseup',\n      function(e) {\n        var clickTime = +new Date(),\n          args;\n\n        pos.x = e.clientX - boundRect.left;\n        pos.y = e.clientY - boundRect.top;\n\n        var nodeAtClientPos = getNodeAtClientPos(pos);\n        var sameNode = nodeAtClientPos === lastFound;\n        args = [nodeAtClientPos || lastFound, e];\n        if (args[0]) {\n          window.document.onselectstart = prevSelectStart;\n\n          if (clickTime - lastClickTime < 400 && sameNode) {\n            invoke(dblClickCallback, args);\n          } else {\n            invoke(clickCallback, args);\n          }\n          lastClickTime = clickTime;\n\n          if (invoke(mouseUpCallback, args)) {\n            stopPropagation(e);\n          }\n        }\n      });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/documentEvents.js":"var nullEvents = require('./nullEvents.js');\n\nmodule.exports = createDocumentEvents();\n\nfunction createDocumentEvents() {\n  if (typeof document === undefined) {\n    return nullEvents;\n  }\n\n  return {\n    on: on,\n    off: off\n  };\n}\n\nfunction on(eventName, handler) {\n  document.addEventListener(eventName, handler);\n}\n\nfunction off(eventName, handler) {\n  document.removeEventListener(eventName, handler);\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/nullEvents.js":"module.exports = createNullEvents();\n\nfunction createNullEvents() {\n  return {\n    on: noop,\n    off: noop,\n    stop: noop\n  };\n}\n\nfunction noop() { }\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Input/domInputManager.js":"/**\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nmodule.exports = domInputManager;\n\nvar dragndrop = require('./dragndrop.js');\n\nfunction domInputManager(graph, graphics) {\n  var nodeEvents = {};\n  return {\n    /**\n     * Called by renderer to listen to drag-n-drop events from node. E.g. for SVG\n     * graphics we may listen to DOM events, whereas for WebGL the graphics\n     * should provide custom eventing mechanism.\n     *\n     * @param node - to be monitored.\n     * @param handlers - object with set of three callbacks:\n     *   onStart: function(),\n     *   onDrag: function(e, offset),\n     *   onStop: function()\n     */\n    bindDragNDrop: bindDragNDrop\n  };\n\n  function bindDragNDrop(node, handlers) {\n    var events;\n    if (handlers) {\n      var nodeUI = graphics.getNodeUI(node.id);\n      events = dragndrop(nodeUI);\n      if (typeof handlers.onStart === 'function') {\n        events.onStart(handlers.onStart);\n      }\n      if (typeof handlers.onDrag === 'function') {\n        events.onDrag(handlers.onDrag);\n      }\n      if (typeof handlers.onStop === 'function') {\n        events.onStop(handlers.onStop);\n      }\n\n      nodeEvents[node.id] = events;\n    } else if ((events = nodeEvents[node.id])) {\n      events.release();\n      delete nodeEvents[node.id];\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Input/dragndrop.js":"/**\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nmodule.exports = dragndrop;\n\nvar documentEvents = require('../Utils/documentEvents.js');\nvar browserInfo = require('../Utils/browserInfo.js');\nvar findElementPosition = require('../Utils/findElementPosition.js');\n\n// TODO: Move to input namespace\n// TODO: Methods should be extracted into the prototype. This class\n// does not need to consume so much memory for every tracked element\nfunction dragndrop(element) {\n    var start,\n        drag,\n        end,\n        scroll,\n        prevSelectStart,\n        prevDragStart,\n\n        startX = 0,\n        startY = 0,\n        dragObject,\n        touchInProgress = false,\n        pinchZoomLength = 0,\n\n        getMousePos = function (e) {\n            var posx = 0,\n                posy = 0;\n\n            e = e || window.event;\n\n            if (e.pageX || e.pageY) {\n                posx = e.pageX;\n                posy = e.pageY;\n            } else if (e.clientX || e.clientY) {\n                posx = e.clientX + window.document.body.scrollLeft + window.document.documentElement.scrollLeft;\n                posy = e.clientY + window.document.body.scrollTop + window.document.documentElement.scrollTop;\n            }\n\n            return [posx, posy];\n        },\n\n        move = function (e, clientX, clientY) {\n            if (drag) {\n                drag(e, {x : clientX - startX, y : clientY - startY });\n            }\n\n            startX = clientX;\n            startY = clientY;\n        },\n\n        stopPropagation = function (e) {\n            if (e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; }\n        },\n        preventDefault = function (e) {\n            if (e.preventDefault) { e.preventDefault(); }\n        },\n\n        handleDisabledEvent = function (e) {\n            stopPropagation(e);\n            return false;\n        },\n\n        handleMouseMove = function (e) {\n            e = e || window.event;\n\n            move(e, e.clientX, e.clientY);\n        },\n\n        handleMouseDown = function (e) {\n            e = e || window.event;\n            if (touchInProgress) {\n                // modern browsers will fire mousedown for touch events too\n                // we do not want this, since touch is handled separately.\n                stopPropagation(e);\n                return false;\n            }\n            // for IE, left click == 1\n            // for Firefox, left click == 0\n            var isLeftButton = ((e.button === 1 && window.event !== null) || e.button === 0);\n\n            if (isLeftButton) {\n                startX = e.clientX;\n                startY = e.clientY;\n\n                // TODO: bump zIndex?\n                dragObject = e.target || e.srcElement;\n\n                if (start) { start(e, {x: startX, y : startY}); }\n\n                documentEvents.on('mousemove', handleMouseMove);\n                documentEvents.on('mouseup', handleMouseUp);\n\n\n                stopPropagation(e);\n                // TODO: What if event already there? Not bullet proof:\n                prevSelectStart = window.document.onselectstart;\n                prevDragStart = window.document.ondragstart;\n\n                window.document.onselectstart = handleDisabledEvent;\n                dragObject.ondragstart = handleDisabledEvent;\n\n                // prevent text selection (except IE)\n                return false;\n            }\n        },\n\n        handleMouseUp = function (e) {\n            e = e || window.event;\n\n            documentEvents.off('mousemove', handleMouseMove);\n            documentEvents.off('mouseup', handleMouseUp);\n\n            window.document.onselectstart = prevSelectStart;\n            dragObject.ondragstart = prevDragStart;\n            dragObject = null;\n            if (end) { end(e); }\n        },\n\n        handleMouseWheel = function (e) {\n            if (typeof scroll !== 'function') {\n                return;\n            }\n\n            e = e || window.event;\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n\n            e.returnValue = false;\n            var delta,\n                mousePos = getMousePos(e),\n                elementOffset = findElementPosition(element),\n                relMousePos = {\n                    x: mousePos[0] - elementOffset[0],\n                    y: mousePos[1] - elementOffset[1]\n                };\n\n            if (e.wheelDelta) {\n                delta = e.wheelDelta / 360; // Chrome/Safari\n            } else {\n                delta = e.detail / -9; // Mozilla\n            }\n\n            scroll(e, delta, relMousePos);\n        },\n\n        updateScrollEvents = function (scrollCallback) {\n            if (!scroll && scrollCallback) {\n                // client is interested in scrolling. Start listening to events:\n                if (browserInfo.browser === 'webkit') {\n                    element.addEventListener('mousewheel', handleMouseWheel, false); // Chrome/Safari\n                } else {\n                    element.addEventListener('DOMMouseScroll', handleMouseWheel, false); // Others\n                }\n            } else if (scroll && !scrollCallback) {\n                if (browserInfo.browser === 'webkit') {\n                    element.removeEventListener('mousewheel', handleMouseWheel, false); // Chrome/Safari\n                } else {\n                    element.removeEventListener('DOMMouseScroll', handleMouseWheel, false); // Others\n                }\n            }\n\n            scroll = scrollCallback;\n        },\n\n        getPinchZoomLength = function(finger1, finger2) {\n            return (finger1.clientX - finger2.clientX) * (finger1.clientX - finger2.clientX) +\n                   (finger1.clientY - finger2.clientY) * (finger1.clientY - finger2.clientY);\n        },\n\n        handleTouchMove = function (e) {\n            if (e.touches.length === 1) {\n                stopPropagation(e);\n\n                var touch = e.touches[0];\n                move(e, touch.clientX, touch.clientY);\n            } else if (e.touches.length === 2) {\n                // it's a zoom:\n                var currentPinchLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n                var delta = 0;\n                if (currentPinchLength < pinchZoomLength) {\n                    delta = -1;\n                } else if (currentPinchLength > pinchZoomLength) {\n                    delta = 1;\n                }\n                scroll(e, delta, {x: e.touches[0].clientX, y: e.touches[0].clientY});\n                pinchZoomLength = currentPinchLength;\n                stopPropagation(e);\n                preventDefault(e);\n            }\n        },\n\n        handleTouchEnd = function (e) {\n            touchInProgress = false;\n            documentEvents.off('touchmove', handleTouchMove);\n            documentEvents.off('touchend', handleTouchEnd);\n            documentEvents.off('touchcancel', handleTouchEnd);\n            dragObject = null;\n            if (end) { end(e); }\n        },\n\n        handleSignleFingerTouch = function (e, touch) {\n            stopPropagation(e);\n            preventDefault(e);\n\n            startX = touch.clientX;\n            startY = touch.clientY;\n\n            dragObject = e.target || e.srcElement;\n\n            if (start) { start(e, {x: startX, y : startY}); }\n            // TODO: can I enter into the state when touch is in progress\n            // but it's still a single finger touch?\n            if (!touchInProgress) {\n                touchInProgress = true;\n                documentEvents.on('touchmove', handleTouchMove);\n                documentEvents.on('touchend', handleTouchEnd);\n                documentEvents.on('touchcancel', handleTouchEnd);\n            }\n        },\n\n        handleTouchStart = function (e) {\n            if (e.touches.length === 1) {\n                return handleSignleFingerTouch(e, e.touches[0]);\n            } else if (e.touches.length === 2) {\n                // handleTouchMove() will care about pinch zoom.\n                stopPropagation(e);\n                preventDefault(e);\n\n                pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n\n            }\n            // don't care about the rest.\n        };\n\n\n    element.addEventListener('mousedown', handleMouseDown);\n    element.addEventListener('touchstart', handleTouchStart);\n\n    return {\n        onStart : function (callback) {\n            start = callback;\n            return this;\n        },\n\n        onDrag : function (callback) {\n            drag = callback;\n            return this;\n        },\n\n        onStop : function (callback) {\n            end = callback;\n            return this;\n        },\n\n        /**\n         * Occurs when mouse wheel event happens. callback = function(e, scrollDelta, scrollPoint);\n         */\n        onScroll : function (callback) {\n            updateScrollEvents(callback);\n            return this;\n        },\n\n        release : function () {\n            // TODO: could be unsafe. We might wanna release dragObject, etc.\n            element.removeEventListener('mousedown', handleMouseDown);\n            element.removeEventListener('touchstart', handleTouchStart);\n\n            documentEvents.off('mousemove', handleMouseMove);\n            documentEvents.off('mouseup', handleMouseUp);\n            documentEvents.off('touchmove', handleTouchMove);\n            documentEvents.off('touchend', handleTouchEnd);\n            documentEvents.off('touchcancel', handleTouchEnd);\n\n            updateScrollEvents(null);\n        }\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/browserInfo.js":"module.exports = browserInfo();\r\n\r\nfunction browserInfo() {\r\n  if (typeof window === \"undefined\" || !window.hasOwnProperty(\"navigator\")) {\r\n    return {\r\n      browser : \"\",\r\n      version : \"0\"\r\n    };\r\n  }\r\n\r\n  var ua = window.navigator.userAgent.toLowerCase(),\r\n  // Useragent RegExp\r\n  rwebkit = /(webkit)[ \\/]([\\w.]+)/,\r\n  ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\r\n  rmsie = /(msie) ([\\w.]+)/,\r\n  rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\r\n  match = rwebkit.exec(ua) ||\r\n    ropera.exec(ua) ||\r\n    rmsie.exec(ua) ||\r\n    (ua.indexOf(\"compatible\") < 0 && rmozilla.exec(ua)) ||\r\n    [];\r\n\r\n  return {\r\n    browser: match[1] || \"\",\r\n    version: match[2] || \"0\"\r\n  };\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/findElementPosition.js":"/**\n * Finds the absolute position of an element on a page\n */\nmodule.exports = findElementPosition;\n\nfunction findElementPosition(obj) {\n    var curleft = 0,\n        curtop = 0;\n    if (obj.offsetParent) {\n        do {\n            curleft += obj.offsetLeft;\n            curtop += obj.offsetTop;\n        } while ((obj = obj.offsetParent) !== null);\n    }\n\n    return [curleft, curtop];\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Input/webglInputManager.js":"/**\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nmodule.exports = webglInputManager;\n\nvar createInputEvents = require('../WebGL/webglInputEvents.js');\n\nfunction webglInputManager(graph, graphics) {\n    var inputEvents = createInputEvents(graphics),\n        draggedNode = null,\n        internalHandlers = {},\n        pos = {x : 0, y : 0};\n\n    inputEvents.mouseDown(function (node, e) {\n        draggedNode = node;\n        pos.x = e.clientX;\n        pos.y = e.clientY;\n\n        inputEvents.mouseCapture(draggedNode);\n\n        var handlers = internalHandlers[node.id];\n        if (handlers && handlers.onStart) {\n            handlers.onStart(e, pos);\n        }\n\n        return true;\n    }).mouseUp(function (node) {\n        inputEvents.releaseMouseCapture(draggedNode);\n\n        draggedNode = null;\n        var handlers = internalHandlers[node.id];\n        if (handlers && handlers.onStop) {\n            handlers.onStop();\n        }\n        return true;\n    }).mouseMove(function (node, e) {\n        if (draggedNode) {\n            var handlers = internalHandlers[draggedNode.id];\n            if (handlers && handlers.onDrag) {\n                handlers.onDrag(e, {x : e.clientX - pos.x, y : e.clientY - pos.y });\n            }\n\n            pos.x = e.clientX;\n            pos.y = e.clientY;\n            return true;\n        }\n    });\n\n    return {\n        /**\n         * Called by renderer to listen to drag-n-drop events from node. E.g. for SVG\n         * graphics we may listen to DOM events, whereas for WebGL we graphics\n         * should provide custom eventing mechanism.\n         *\n         * @param node - to be monitored.\n         * @param handlers - object with set of three callbacks:\n         *   onStart: function(),\n         *   onDrag: function(e, offset),\n         *   onStop: function()\n         */\n        bindDragNDrop : function (node, handlers) {\n            internalHandlers[node.id] = handlers;\n            if (!handlers) {\n                delete internalHandlers[node.id];\n            }\n        }\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/timer.js":"/**\r\n * @author Andrei Kashcha (aka anvaka) / http://anvaka.blogspot.com\r\n */\r\n\r\nmodule.exports = createTimer();\r\n\r\nfunction createTimer() {\r\n  var lastTime = 0,\r\n    vendors = ['ms', 'moz', 'webkit', 'o'],\r\n    i,\r\n    scope;\r\n\r\n  if (typeof window !== 'undefined') {\r\n    scope = window;\r\n  } else if (typeof global !== 'undefined') {\r\n    scope = global;\r\n  } else {\r\n    scope = {\r\n      setTimeout: noop,\r\n      clearTimeout: noop\r\n    };\r\n  }\r\n\r\n  for (i = 0; i < vendors.length && !scope.requestAnimationFrame; ++i) {\r\n    var vendorPrefix = vendors[i];\r\n    scope.requestAnimationFrame = scope[vendorPrefix + 'RequestAnimationFrame'];\r\n    scope.cancelAnimationFrame =\r\n      scope[vendorPrefix + 'CancelAnimationFrame'] || scope[vendorPrefix + 'CancelRequestAnimationFrame'];\r\n  }\r\n\r\n  if (!scope.requestAnimationFrame) {\r\n    scope.requestAnimationFrame = rafPolyfill;\r\n  }\r\n\r\n  if (!scope.cancelAnimationFrame) {\r\n    scope.cancelAnimationFrame = cancelRafPolyfill;\r\n  }\r\n\r\n  return timer;\r\n\r\n  /**\r\n   * Timer that fires callback with given interval (in ms) until\r\n   * callback returns true;\r\n   */\r\n  function timer(callback) {\r\n    var intervalId;\r\n    startTimer(); // start it right away.\r\n\r\n    return {\r\n      /**\r\n       * Stops execution of the callback\r\n       */\r\n      stop: stopTimer,\r\n\r\n      restart: restart\r\n    };\r\n\r\n    function startTimer() {\r\n      intervalId = scope.requestAnimationFrame(startTimer);\r\n      if (!callback()) {\r\n        stopTimer();\r\n      }\r\n    }\r\n\r\n    function stopTimer() {\r\n      scope.cancelAnimationFrame(intervalId);\r\n      intervalId = 0;\r\n    }\r\n\r\n    function restart() {\r\n      if (!intervalId) {\r\n        startTimer();\r\n      }\r\n    }\r\n  }\r\n\r\n  function rafPolyfill(callback) {\r\n    var currTime = new Date().getTime();\r\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n    var id = scope.setTimeout(function() {\r\n      callback(currTime + timeToCall);\r\n    }, timeToCall);\r\n    lastTime = currTime + timeToCall;\r\n    return id;\r\n  }\r\n\r\n  function cancelRafPolyfill(id) {\r\n    scope.clearTimeout(id);\r\n  }\r\n}\r\n\r\nfunction noop() {}\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/getDimensions.js":"module.exports = getDimension;\r\n\r\nfunction getDimension(container) {\r\n    if (!container) {\r\n        throw {\r\n            message : 'Cannot get dimensions of undefined container'\r\n        };\r\n    }\r\n\r\n    // TODO: Potential cross browser bug.\r\n    var width = container.clientWidth;\r\n    var height = container.clientHeight;\r\n\r\n    return {\r\n        left : 0,\r\n        top : 0,\r\n        width : width,\r\n        height : height\r\n    };\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/backwardCompatibleEvents.js":"/**\n * This module provides compatibility layer with 0.6.x library. It will be\n * removed in the next version\n */\n\nvar events = require('ngraph.events');\n\nmodule.exports = backwardCompatibleEvents;\n\nfunction backwardCompatibleEvents(g) {\n  console.log(\"This method is deprecated. Please use Viva.events() instead\");\n\n  if (!g) {\n    return g;\n  }\n\n  var eventsDefined = (g.on !== undefined) ||\n    (g.off !== undefined) ||\n    (g.fire !== undefined);\n\n  if (eventsDefined) {\n    // events already defined, ignore\n    return {\n      extend: function() {\n        return g;\n      },\n      on: g.on,\n      stop: g.off\n    };\n  }\n\n  return {\n    extend: extend,\n    on: g.on,\n    stop: g.off\n  };\n\n  function extend() {\n    var backwardCompatible = events(g);\n    backwardCompatible.addEventListener = backwardCompatible.on;\n    return backwardCompatible;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Layout/constant.js":"module.exports = constant;\n\nvar merge = require('ngraph.merge');\nvar random = require('ngraph.random').random;\nvar Rect = require('../Utils/rect.js');\n\n/**\n * Does not really perform any layouting algorithm but is compliant\n * with renderer interface. Allowing clients to provide specific positioning\n * callback and get static layout of the graph\n *\n * @param {Viva.Graph.graph} graph to layout\n * @param {Object} userSettings\n */\nfunction constant(graph, userSettings) {\n    userSettings = merge(userSettings, {\n        maxX : 1024,\n        maxY : 1024,\n        seed : 'Deterministic randomness made me do this'\n    });\n    // This class simply follows API, it does not use some of the arguments:\n    /*jshint unused: false */\n    var rand = random(userSettings.seed),\n        graphRect = new Rect(Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE),\n        layoutLinks = {},\n\n        placeNodeCallback = function (node) {\n            return {\n              x: rand.next(userSettings.maxX),\n              y: rand.next(userSettings.maxY)\n            };\n        },\n\n        updateGraphRect = function (position, graphRect) {\n            if (position.x < graphRect.x1) { graphRect.x1 = position.x; }\n            if (position.x > graphRect.x2) { graphRect.x2 = position.x; }\n            if (position.y < graphRect.y1) { graphRect.y1 = position.y; }\n            if (position.y > graphRect.y2) { graphRect.y2 = position.y; }\n        },\n\n        layoutNodes = typeof Object.create === 'function' ? Object.create(null) : {},\n\n        ensureNodeInitialized = function (node) {\n            layoutNodes[node.id] = placeNodeCallback(node);\n            updateGraphRect(layoutNodes[node.id], graphRect);\n        },\n\n        updateNodePositions = function () {\n            if (graph.getNodesCount() === 0) { return; }\n\n            graphRect.x1 = Number.MAX_VALUE;\n            graphRect.y1 = Number.MAX_VALUE;\n            graphRect.x2 = Number.MIN_VALUE;\n            graphRect.y2 = Number.MIN_VALUE;\n\n            graph.forEachNode(ensureNodeInitialized);\n        },\n\n        ensureLinkInitialized = function (link) {\n          layoutLinks[link.id] = link;\n        },\n\n        onGraphChanged = function(changes) {\n            for (var i = 0; i < changes.length; ++i) {\n                var change = changes[i];\n                if (change.node) {\n                    if (change.changeType === 'add') {\n                        ensureNodeInitialized(change.node);\n                    } else {\n                        delete layoutNodes[change.node.id];\n                    }\n                } if (change.link) {\n                    if (change.changeType === 'add') {\n                        ensureLinkInitialized(change.link);\n                    } else {\n                        delete layoutLinks[change.link.id];\n                    }\n                }\n            }\n        };\n\n    graph.forEachNode(ensureNodeInitialized);\n    graph.forEachLink(ensureLinkInitialized);\n    graph.on('changed', onGraphChanged);\n\n    return {\n        /**\n         * Attempts to layout graph within given number of iterations.\n         *\n         * @param {integer} [iterationsCount] number of algorithm's iterations.\n         *  The constant layout ignores this parameter.\n         */\n        run : function (iterationsCount) {\n            this.step();\n        },\n\n        /**\n         * One step of layout algorithm.\n         */\n        step : function () {\n            updateNodePositions();\n\n            return true; // no need to continue.\n        },\n\n        /**\n         * Returns rectangle structure {x1, y1, x2, y2}, which represents\n         * current space occupied by graph.\n         */\n        getGraphRect : function () {\n            return graphRect;\n        },\n\n        /**\n         * Request to release all resources\n         */\n        dispose : function () {\n            graph.off('change', onGraphChanged);\n        },\n\n        /*\n         * Checks whether given node is pinned; all nodes in this layout are pinned.\n         */\n        isNodePinned: function (node) {\n            return true;\n        },\n\n        /*\n         * Requests layout algorithm to pin/unpin node to its current position\n         * Pinned nodes should not be affected by layout algorithm and always\n         * remain at their position\n         */\n        pinNode: function (node, isPinned) {\n           // noop\n        },\n\n        /*\n         * Gets position of a node by its id. If node was not seen by this\n         * layout algorithm undefined value is returned;\n         */\n        getNodePosition: getNodePosition,\n\n        /**\n         * Returns {from, to} position of a link.\n         */\n        getLinkPosition: function (linkId) {\n          var link = layoutLinks[linkId];\n          return {\n              from : getNodePosition(link.fromId),\n              to : getNodePosition(link.toId)\n          };\n        },\n\n        /**\n         * Sets position of a node to a given coordinates\n         */\n        setNodePosition: function (nodeId, x, y) {\n            var pos = layoutNodes[nodeId];\n            if (pos) {\n                pos.x = x;\n                pos.y = y;\n            }\n        },\n\n        // Layout specific methods:\n\n        /**\n         * Based on argument either update default node placement callback or\n         * attempts to place given node using current placement callback.\n         * Setting new node callback triggers position update for all nodes.\n         *\n         * @param {Object} newPlaceNodeCallbackOrNode - if it is a function then\n         * default node placement callback is replaced with new one. Node placement\n         * callback has a form of function (node) {}, and is expected to return an\n         * object with x and y properties set to numbers.\n         *\n         * Otherwise if it's not a function the argument is treated as graph node\n         * and current node placement callback will be used to place it.\n         */\n        placeNode : function (newPlaceNodeCallbackOrNode) {\n            if (typeof newPlaceNodeCallbackOrNode === 'function') {\n                placeNodeCallback = newPlaceNodeCallbackOrNode;\n                updateNodePositions();\n                return this;\n            }\n\n            // it is not a request to update placeNodeCallback, trying to place\n            // a node using current callback:\n            return placeNodeCallback(newPlaceNodeCallbackOrNode);\n        }\n\n    };\n\n    function getNodePosition(nodeId) {\n        return layoutNodes[nodeId];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/rect.js":"module.exports = Rect;\n\n/**\n * Very generic rectangle.\n */\nfunction Rect (x1, y1, x2, y2) {\n    this.x1 = x1 || 0;\n    this.y1 = y1 || 0;\n    this.x2 = x2 || 0;\n    this.y2 = y2 || 0;\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/texture.js":"module.exports = Texture;\n\n/**\n * Single texture in the webglAtlas.\n */\nfunction Texture(size) {\n  this.canvas = window.document.createElement(\"canvas\");\n  this.ctx = this.canvas.getContext(\"2d\");\n  this.isDirty = false;\n  this.canvas.width = this.canvas.height = size;\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglAtlas.js":"var Texture = require('./texture.js');\n\nmodule.exports = webglAtlas;\n\n/**\n * My naive implementation of textures atlas. It allows clients to load\n * multiple images into atlas and get canvas representing all of them.\n *\n * @param tilesPerTexture - indicates how many images can be loaded to one\n *          texture of the atlas. If number of loaded images exceeds this\n *          parameter a new canvas will be created.\n */\nfunction webglAtlas(tilesPerTexture) {\n  var tilesPerRow = Math.sqrt(tilesPerTexture || 1024) << 0,\n    tileSize = tilesPerRow,\n    lastLoadedIdx = 1,\n    loadedImages = {},\n    dirtyTimeoutId,\n    skipedDirty = 0,\n    textures = [],\n    trackedUrls = [];\n\n  if (!isPowerOf2(tilesPerTexture)) {\n    throw \"Tiles per texture should be power of two.\";\n  }\n\n  // this is the return object\n  var api = {\n    /**\n     * indicates whether atlas has changed texture in it. If true then\n     * some of the textures has isDirty flag set as well.\n     */\n    isDirty: false,\n\n    /**\n     * Clears any signs of atlas changes.\n     */\n    clearDirty: clearDirty,\n\n    /**\n     * Removes given url from collection of tiles in the atlas.\n     */\n    remove: remove,\n\n    /**\n     * Gets all textures in the atlas.\n     */\n    getTextures: getTextures,\n\n    /**\n     * Gets coordinates of the given image in the atlas. Coordinates is an object:\n     * {offset : int } - where offset is an absolute position of the image in the\n     * atlas.\n     *\n     * Absolute means it can be larger than tilesPerTexture parameter, and in that\n     * case clients should get next texture in getTextures() collection.\n     */\n    getCoordinates: getCoordinates,\n\n    /**\n     * Asynchronously Loads the image to the atlas. Cross-domain security\n     * limitation applies.\n     */\n    load: load\n  };\n\n  return api;\n\n  function clearDirty() {\n    var i;\n    api.isDirty = false;\n    for (i = 0; i < textures.length; ++i) {\n      textures[i].isDirty = false;\n    }\n  }\n\n  function remove(imgUrl) {\n    var coordinates = loadedImages[imgUrl];\n    if (!coordinates) {\n      return false;\n    }\n    delete loadedImages[imgUrl];\n    lastLoadedIdx -= 1;\n\n\n    if (lastLoadedIdx === coordinates.offset) {\n      return true; // Ignore if it's last image in the whole set.\n    }\n\n    var tileToRemove = getTileCoordinates(coordinates.offset),\n      lastTileInSet = getTileCoordinates(lastLoadedIdx);\n\n    copy(lastTileInSet, tileToRemove);\n\n    var replacedOffset = loadedImages[trackedUrls[lastLoadedIdx]];\n    replacedOffset.offset = coordinates.offset;\n    trackedUrls[coordinates.offset] = trackedUrls[lastLoadedIdx];\n\n    markDirty();\n    return true;\n  }\n\n  function getTextures() {\n    return textures; // I trust you...\n  }\n\n  function getCoordinates(imgUrl) {\n    return loadedImages[imgUrl];\n  }\n\n  function load(imgUrl, callback) {\n    if (loadedImages.hasOwnProperty(imgUrl)) {\n      callback(loadedImages[imgUrl]);\n    } else {\n      var img = new window.Image(),\n        imgId = lastLoadedIdx;\n\n      lastLoadedIdx += 1;\n      img.crossOrigin = \"anonymous\";\n      img.onload = function() {\n        markDirty();\n        drawAt(imgId, img, callback);\n      };\n\n      img.src = imgUrl;\n    }\n  }\n\n  function createTexture() {\n    var texture = new Texture(tilesPerRow * tileSize);\n    textures.push(texture);\n  }\n\n  function drawAt(tileNumber, img, callback) {\n    var tilePosition = getTileCoordinates(tileNumber),\n      coordinates = {\n        offset: tileNumber\n      };\n\n    if (tilePosition.textureNumber >= textures.length) {\n      createTexture();\n    }\n    var currentTexture = textures[tilePosition.textureNumber];\n\n    currentTexture.ctx.drawImage(img, tilePosition.col * tileSize, tilePosition.row * tileSize, tileSize, tileSize);\n    trackedUrls[tileNumber] = img.src;\n\n    loadedImages[img.src] = coordinates;\n    currentTexture.isDirty = true;\n\n    callback(coordinates);\n  }\n\n  function getTileCoordinates(absolutePosition) {\n    var textureNumber = (absolutePosition / tilesPerTexture) << 0,\n      localTileNumber = (absolutePosition % tilesPerTexture),\n      row = (localTileNumber / tilesPerRow) << 0,\n      col = (localTileNumber % tilesPerRow);\n\n    return {\n      textureNumber: textureNumber,\n      row: row,\n      col: col\n    };\n  }\n\n  function markDirtyNow() {\n    api.isDirty = true;\n    skipedDirty = 0;\n    dirtyTimeoutId = null;\n  }\n\n  function markDirty() {\n    // delay this call, since it results in texture reload\n    if (dirtyTimeoutId) {\n      window.clearTimeout(dirtyTimeoutId);\n      skipedDirty += 1;\n      dirtyTimeoutId = null;\n    }\n\n    if (skipedDirty > 10) {\n      markDirtyNow();\n    } else {\n      dirtyTimeoutId = window.setTimeout(markDirtyNow, 400);\n    }\n  }\n\n  function copy(from, to) {\n    var fromCanvas = textures[from.textureNumber].canvas,\n      toCtx = textures[to.textureNumber].ctx,\n      x = to.col * tileSize,\n      y = to.row * tileSize;\n\n    toCtx.drawImage(fromCanvas, from.col * tileSize, from.row * tileSize, tileSize, tileSize, x, y, tileSize, tileSize);\n    textures[from.textureNumber].isDirty = true;\n    textures[to.textureNumber].isDirty = true;\n  }\n}\n\nfunction isPowerOf2(n) {\n  return (n & (n - 1)) === 0;\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglImageNodeProgram.js":"/**\n * @fileOverview Defines an image nodes for webglGraphics class.\n * Shape of nodes is square.\n *\n * @author Andrei Kashcha (aka anvaka) / http://anvaka.blogspot.com\n */\n\nvar WebglAtlas = require('./webglAtlas.js');\nvar glUtils = require('./webgl.js');\n\nmodule.exports = webglImageNodeProgram;\n\n/**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as an image.\n */\nfunction webglImageNodeProgram() {\n  // WebGL is gian state machine, we store some properties of the state here:\n  var ATTRIBUTES_PER_PRIMITIVE = 18;\n  var nodesFS = createNodeFragmentShader();\n  var nodesVS = createNodeVertexShader();\n  var tilesPerTexture = 1024; // TODO: Get based on max texture size\n  var atlas;\n  var program;\n  var gl;\n  var buffer;\n  var utils;\n  var locations;\n  var nodesCount = 0;\n  var nodes = new Float32Array(64);\n  var width;\n  var height;\n  var transform;\n  var sizeDirty;\n\n\n  return {\n    load: load,\n\n    /**\n     * Updates position of current node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n    position: position,\n\n    createNode: createNode,\n\n    removeNode: removeNode,\n\n    replaceProperties: replaceProperties,\n\n    updateTransform: updateTransform,\n\n    updateSize: updateSize,\n\n    render: render\n  };\n\n  function refreshTexture(texture, idx) {\n    if (texture.nativeObject) {\n      gl.deleteTexture(texture.nativeObject);\n    }\n\n    var nativeObject = gl.createTexture();\n    gl.activeTexture(gl[\"TEXTURE\" + idx]);\n    gl.bindTexture(gl.TEXTURE_2D, nativeObject);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.canvas);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n\n    gl.generateMipmap(gl.TEXTURE_2D);\n    gl.uniform1i(locations[\"sampler\" + idx], idx);\n\n    texture.nativeObject = nativeObject;\n  }\n\n  function ensureAtlasTextureUpdated() {\n    if (atlas.isDirty) {\n      var textures = atlas.getTextures(),\n        i;\n      for (i = 0; i < textures.length; ++i) {\n        if (textures[i].isDirty || !textures[i].nativeObject) {\n          refreshTexture(textures[i], i);\n        }\n      }\n\n      atlas.clearDirty();\n    }\n  }\n\n  function load(glContext) {\n    gl = glContext;\n    utils = glUtils(glContext);\n\n    atlas = new WebglAtlas(tilesPerTexture);\n\n    program = utils.createProgram(nodesVS, nodesFS);\n    gl.useProgram(program);\n    locations = utils.getLocations(program, [\"a_vertexPos\", \"a_customAttributes\", \"u_screenSize\", \"u_transform\", \"u_sampler0\", \"u_sampler1\", \"u_sampler2\", \"u_sampler3\", \"u_tilesPerTexture\"]);\n\n    gl.uniform1f(locations.tilesPerTexture, tilesPerTexture);\n\n    gl.enableVertexAttribArray(locations.vertexPos);\n    gl.enableVertexAttribArray(locations.customAttributes);\n\n    buffer = gl.createBuffer();\n  }\n\n  function position(nodeUI, pos) {\n    var idx = nodeUI.id * ATTRIBUTES_PER_PRIMITIVE;\n    nodes[idx] = pos.x - nodeUI.size;\n    nodes[idx + 1] = pos.y - nodeUI.size;\n    nodes[idx + 2] = nodeUI._offset * 4;\n\n    nodes[idx + 3] = pos.x + nodeUI.size;\n    nodes[idx + 4] = pos.y - nodeUI.size;\n    nodes[idx + 5] = nodeUI._offset * 4 + 1;\n\n    nodes[idx + 6] = pos.x - nodeUI.size;\n    nodes[idx + 7] = pos.y + nodeUI.size;\n    nodes[idx + 8] = nodeUI._offset * 4 + 2;\n\n    nodes[idx + 9] = pos.x - nodeUI.size;\n    nodes[idx + 10] = pos.y + nodeUI.size;\n    nodes[idx + 11] = nodeUI._offset * 4 + 2;\n\n    nodes[idx + 12] = pos.x + nodeUI.size;\n    nodes[idx + 13] = pos.y - nodeUI.size;\n    nodes[idx + 14] = nodeUI._offset * 4 + 1;\n\n    nodes[idx + 15] = pos.x + nodeUI.size;\n    nodes[idx + 16] = pos.y + nodeUI.size;\n    nodes[idx + 17] = nodeUI._offset * 4 + 3;\n  }\n\n  function createNode(ui) {\n    nodes = utils.extendArray(nodes, nodesCount, ATTRIBUTES_PER_PRIMITIVE);\n    nodesCount += 1;\n\n    var coordinates = atlas.getCoordinates(ui.src);\n    if (coordinates) {\n      ui._offset = coordinates.offset;\n    } else {\n      ui._offset = 0;\n      // Image is not yet loaded into the atlas. Reload it:\n      atlas.load(ui.src, function(coordinates) {\n        ui._offset = coordinates.offset;\n      });\n    }\n  }\n\n  function removeNode(nodeUI) {\n    if (nodesCount > 0) {\n      nodesCount -= 1;\n    }\n\n    if (nodeUI.id < nodesCount && nodesCount > 0) {\n      if (nodeUI.src) {\n        atlas.remove(nodeUI.src);\n      }\n\n      utils.copyArrayPart(nodes, nodeUI.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n    }\n  }\n\n  function replaceProperties(replacedNode, newNode) {\n    newNode._offset = replacedNode._offset;\n  }\n\n  function updateTransform(newTransform) {\n    sizeDirty = true;\n    transform = newTransform;\n  }\n\n  function updateSize(w, h) {\n    width = w;\n    height = h;\n    sizeDirty = true;\n  }\n\n  function render() {\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, nodes, gl.DYNAMIC_DRAW);\n\n    if (sizeDirty) {\n      sizeDirty = false;\n      gl.uniformMatrix4fv(locations.transform, false, transform);\n      gl.uniform2f(locations.screenSize, width, height);\n    }\n\n    gl.vertexAttribPointer(locations.vertexPos, 2, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(locations.customAttributes, 1, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 2 * 4);\n\n    ensureAtlasTextureUpdated();\n\n    gl.drawArrays(gl.TRIANGLES, 0, nodesCount * 6);\n  }\n}\n\n// TODO: Use glslify for shaders\nfunction createNodeFragmentShader() {\n  return [\n    \"precision mediump float;\",\n    \"varying vec4 color;\",\n    \"varying vec3 vTextureCoord;\",\n    \"uniform sampler2D u_sampler0;\",\n    \"uniform sampler2D u_sampler1;\",\n    \"uniform sampler2D u_sampler2;\",\n    \"uniform sampler2D u_sampler3;\",\n\n    \"void main(void) {\",\n    \"   if (vTextureCoord.z == 0.) {\",\n    \"     gl_FragColor = texture2D(u_sampler0, vTextureCoord.xy);\",\n    \"   } else if (vTextureCoord.z == 1.) {\",\n    \"     gl_FragColor = texture2D(u_sampler1, vTextureCoord.xy);\",\n    \"   } else if (vTextureCoord.z == 2.) {\",\n    \"     gl_FragColor = texture2D(u_sampler2, vTextureCoord.xy);\",\n    \"   } else if (vTextureCoord.z == 3.) {\",\n    \"     gl_FragColor = texture2D(u_sampler3, vTextureCoord.xy);\",\n    \"   } else { gl_FragColor = vec4(0, 1, 0, 1); }\",\n    \"}\"\n  ].join(\"\\n\");\n}\n\nfunction createNodeVertexShader() {\n  return [\n    \"attribute vec2 a_vertexPos;\",\n\n    \"attribute float a_customAttributes;\",\n    \"uniform vec2 u_screenSize;\",\n    \"uniform mat4 u_transform;\",\n    \"uniform float u_tilesPerTexture;\",\n    \"varying vec3 vTextureCoord;\",\n\n    \"void main(void) {\",\n    \"   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0, 1);\",\n    \"float corner = mod(a_customAttributes, 4.);\",\n    \"float tileIndex = mod(floor(a_customAttributes / 4.), u_tilesPerTexture);\",\n    \"float tilesPerRow = sqrt(u_tilesPerTexture);\",\n    \"float tileSize = 1./tilesPerRow;\",\n    \"float tileColumn = mod(tileIndex, tilesPerRow);\",\n    \"float tileRow = floor(tileIndex/tilesPerRow);\",\n\n    \"if(corner == 0.0) {\",\n    \"  vTextureCoord.xy = vec2(0, 1);\",\n    \"} else if(corner == 1.0) {\",\n    \"  vTextureCoord.xy = vec2(1, 1);\",\n    \"} else if(corner == 2.0) {\",\n    \"  vTextureCoord.xy = vec2(0, 0);\",\n    \"} else {\",\n    \"  vTextureCoord.xy = vec2(1, 0);\",\n    \"}\",\n\n    \"vTextureCoord *= tileSize;\",\n    \"vTextureCoord.x += tileColumn * tileSize;\",\n    \"vTextureCoord.y += tileRow * tileSize;\",\n    \"vTextureCoord.z = floor(floor(a_customAttributes / 4.)/u_tilesPerTexture);\",\n    \"}\"\n  ].join(\"\\n\");\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglLinkProgram.js":"/**\n * @fileOverview Defines a naive form of links for webglGraphics class.\n * This form allows to change color of links.\n **/\n\nvar glUtils = require('./webgl.js');\n\nmodule.exports = webglLinkProgram;\n\n/**\n * Defines UI for links in webgl renderer.\n */\nfunction webglLinkProgram() {\n    var ATTRIBUTES_PER_PRIMITIVE = 6, // primitive is Line with two points. Each has x,y and color = 3 * 2 attributes.\n        BYTES_PER_LINK = 2 * (2 * Float32Array.BYTES_PER_ELEMENT + Uint32Array.BYTES_PER_ELEMENT), // two nodes * (x, y + color)\n        linksFS = [\n            'precision mediump float;',\n            'varying vec4 color;',\n            'void main(void) {',\n            '   gl_FragColor = color;',\n            '}'\n        ].join('\\n'),\n\n        linksVS = [\n            'attribute vec2 a_vertexPos;',\n            'attribute vec4 a_color;',\n\n            'uniform vec2 u_screenSize;',\n            'uniform mat4 u_transform;',\n\n            'varying vec4 color;',\n\n            'void main(void) {',\n            '   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0.0, 1.0);',\n            '   color = a_color.abgr;',\n            '}'\n        ].join('\\n'),\n\n        program,\n        gl,\n        buffer,\n        utils,\n        locations,\n        linksCount = 0,\n        frontLinkId, // used to track z-index of links.\n        storage = new ArrayBuffer(16 * BYTES_PER_LINK),\n        positions = new Float32Array(storage),\n        colors = new Uint32Array(storage),\n        width,\n        height,\n        transform,\n        sizeDirty,\n\n        ensureEnoughStorage = function () {\n            // TODO: this is a duplicate of webglNodeProgram code. Extract it to webgl.js\n            if ((linksCount+1)*BYTES_PER_LINK > storage.byteLength) {\n                // Every time we run out of space create new array twice bigger.\n                // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n                var extendedStorage = new ArrayBuffer(storage.byteLength * 2),\n                    extendedPositions = new Float32Array(extendedStorage),\n                    extendedColors = new Uint32Array(extendedStorage);\n\n                extendedColors.set(colors); // should be enough to copy just one view.\n                positions = extendedPositions;\n                colors = extendedColors;\n                storage = extendedStorage;\n            }\n        };\n\n    return {\n        load : function (glContext) {\n            gl = glContext;\n            utils = glUtils(glContext);\n\n            program = utils.createProgram(linksVS, linksFS);\n            gl.useProgram(program);\n            locations = utils.getLocations(program, ['a_vertexPos', 'a_color', 'u_screenSize', 'u_transform']);\n\n            gl.enableVertexAttribArray(locations.vertexPos);\n            gl.enableVertexAttribArray(locations.color);\n\n            buffer = gl.createBuffer();\n        },\n\n        position: function (linkUi, fromPos, toPos) {\n            var linkIdx = linkUi.id,\n                offset = linkIdx * ATTRIBUTES_PER_PRIMITIVE;\n            positions[offset] = fromPos.x;\n            positions[offset + 1] = fromPos.y;\n            colors[offset + 2] = linkUi.color;\n\n            positions[offset + 3] = toPos.x;\n            positions[offset + 4] = toPos.y;\n            colors[offset + 5] = linkUi.color;\n        },\n\n        createLink : function (ui) {\n            ensureEnoughStorage();\n\n            linksCount += 1;\n            frontLinkId = ui.id;\n        },\n\n        removeLink : function (ui) {\n            if (linksCount > 0) { linksCount -= 1; }\n            // swap removed link with the last link. This will give us O(1) performance for links removal:\n            if (ui.id < linksCount && linksCount > 0) {\n                // using colors as a view to array buffer is okay here.\n                utils.copyArrayPart(colors, ui.id * ATTRIBUTES_PER_PRIMITIVE, linksCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n            }\n        },\n\n        updateTransform : function (newTransform) {\n            sizeDirty = true;\n            transform = newTransform;\n        },\n\n        updateSize : function (w, h) {\n            width = w;\n            height = h;\n            sizeDirty = true;\n        },\n\n        render : function () {\n            gl.useProgram(program);\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, storage, gl.DYNAMIC_DRAW);\n\n            if (sizeDirty) {\n                sizeDirty = false;\n                gl.uniformMatrix4fv(locations.transform, false, transform);\n                gl.uniform2f(locations.screenSize, width, height);\n            }\n\n            gl.vertexAttribPointer(locations.vertexPos, 2, gl.FLOAT, false, 3 * Float32Array.BYTES_PER_ELEMENT, 0);\n            gl.vertexAttribPointer(locations.color, 4, gl.UNSIGNED_BYTE, true, 3 * Float32Array.BYTES_PER_ELEMENT, 2 * 4);\n\n            gl.drawArrays(gl.LINES, 0, linksCount * 2);\n\n            frontLinkId = linksCount - 1;\n        },\n\n        bringToFront : function (link) {\n            if (frontLinkId > link.id) {\n                utils.swapArrayPart(positions, link.id * ATTRIBUTES_PER_PRIMITIVE, frontLinkId * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n            }\n            if (frontLinkId > 0) {\n                frontLinkId -= 1;\n            }\n        },\n\n        getFrontLinkId : function () {\n            return frontLinkId;\n        }\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglNodeProgram.js":"/**\n * @fileOverview Defines a naive form of nodes for webglGraphics class.\n * This form allows to change color of node. Shape of nodes is rectangular.\n *\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\n */\n\nvar glUtils = require('./webgl.js');\n\nmodule.exports = webglNodeProgram;\n\n/**\n * Defines simple UI for nodes in webgl renderer. Each node is rendered as square. Color and size can be changed.\n */\nfunction webglNodeProgram() {\n  var ATTRIBUTES_PER_PRIMITIVE = 4; // Primitive is point, x, y, size, color\n  // x, y, z - floats, color = uint.\n  var BYTES_PER_NODE = 3 * Float32Array.BYTES_PER_ELEMENT + Uint32Array.BYTES_PER_ELEMENT;\n  var nodesFS = [\n    'precision mediump float;',\n    'varying vec4 color;',\n\n    'void main(void) {',\n    '   gl_FragColor = color;',\n    '}'\n  ].join('\\n');\n  var nodesVS = [\n    'attribute vec3 a_vertexPos;',\n    'attribute vec4 a_color;',\n    'uniform vec2 u_screenSize;',\n    'uniform mat4 u_transform;',\n    'varying vec4 color;',\n\n    'void main(void) {',\n    '   gl_Position = u_transform * vec4(a_vertexPos.xy/u_screenSize, 0, 1);',\n    '   gl_PointSize = a_vertexPos.z * u_transform[0][0];',\n    '   color = a_color.abgr;',\n    '}'\n  ].join('\\n');\n\n  var program;\n  var gl;\n  var buffer;\n  var locations;\n  var utils;\n  var storage = new ArrayBuffer(16 * BYTES_PER_NODE);\n  var positions = new Float32Array(storage);\n  var colors = new Uint32Array(storage);\n  var nodesCount = 0;\n  var width;\n  var height;\n  var transform;\n  var sizeDirty;\n\n  return {\n    load: load,\n\n    /**\n     * Updates position of node in the buffer of nodes.\n     *\n     * @param idx - index of current node.\n     * @param pos - new position of the node.\n     */\n    position: position,\n\n    updateTransform: updateTransform,\n\n    updateSize: updateSize,\n\n    removeNode: removeNode,\n\n    createNode: createNode,\n\n    replaceProperties: replaceProperties,\n\n    render: render\n  };\n\n  function ensureEnoughStorage() {\n    if ((nodesCount + 1) * BYTES_PER_NODE >= storage.byteLength) {\n      // Every time we run out of space create new array twice bigger.\n      // TODO: it seems buffer size is limited. Consider using multiple arrays for huge graphs\n      var extendedStorage = new ArrayBuffer(storage.byteLength * 2),\n        extendedPositions = new Float32Array(extendedStorage),\n        extendedColors = new Uint32Array(extendedStorage);\n\n      extendedColors.set(colors); // should be enough to copy just one view.\n      positions = extendedPositions;\n      colors = extendedColors;\n      storage = extendedStorage;\n    }\n  }\n\n  function load(glContext) {\n    gl = glContext;\n    utils = glUtils(glContext);\n\n    program = utils.createProgram(nodesVS, nodesFS);\n    gl.useProgram(program);\n    locations = utils.getLocations(program, ['a_vertexPos', 'a_color', 'u_screenSize', 'u_transform']);\n\n    gl.enableVertexAttribArray(locations.vertexPos);\n    gl.enableVertexAttribArray(locations.color);\n\n    buffer = gl.createBuffer();\n  }\n\n  function position(nodeUI, pos) {\n    var idx = nodeUI.id;\n\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE] = pos.x;\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE + 1] = -pos.y;\n    positions[idx * ATTRIBUTES_PER_PRIMITIVE + 2] = nodeUI.size;\n\n    colors[idx * ATTRIBUTES_PER_PRIMITIVE + 3] = nodeUI.color;\n  }\n\n  function updateTransform(newTransform) {\n    sizeDirty = true;\n    transform = newTransform;\n  }\n\n  function updateSize(w, h) {\n    width = w;\n    height = h;\n    sizeDirty = true;\n  }\n\n  function removeNode(node) {\n      if (nodesCount > 0) {\n        nodesCount -= 1;\n      }\n\n      if (node.id < nodesCount && nodesCount > 0) {\n        // we can use colors as a 'view' into array array buffer.\n        utils.copyArrayPart(colors, node.id * ATTRIBUTES_PER_PRIMITIVE, nodesCount * ATTRIBUTES_PER_PRIMITIVE, ATTRIBUTES_PER_PRIMITIVE);\n      }\n    }\n\n  function createNode() {\n    ensureEnoughStorage();\n    nodesCount += 1;\n  }\n\n  function replaceProperties(/* replacedNode, newNode */) {}\n\n  function render() {\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, storage, gl.DYNAMIC_DRAW);\n\n    if (sizeDirty) {\n      sizeDirty = false;\n      gl.uniformMatrix4fv(locations.transform, false, transform);\n      gl.uniform2f(locations.screenSize, width, height);\n    }\n\n    gl.vertexAttribPointer(locations.vertexPos, 3, gl.FLOAT, false, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(locations.color, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES_PER_PRIMITIVE * Float32Array.BYTES_PER_ELEMENT, 3 * 4);\n\n    gl.drawArrays(gl.POINTS, 0, nodesCount);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglLine.js":"var parseColor = require('./parseColor.js');\n\nmodule.exports = webglLine;\n\n/**\n * Defines a webgl line. This class has no rendering logic at all,\n * it's just passed to corresponding shader and the shader should\n * figure out how to render it.\n *\n */\nfunction webglLine(color) {\n  return {\n    /**\n     * Gets or sets color of the line. If you set this property externally\n     * make sure it always come as integer of 0xRRGGBBAA format\n     */\n    color: parseColor(color)\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/parseColor.js":"module.exports = parseColor;\n\nfunction parseColor(color) {\n  var parsedColor = 0x009ee8ff;\n\n  if (typeof color === 'string' && color) {\n    if (color.length === 4) { // #rgb\n      color = color.replace(/([^#])/g, '$1$1'); // duplicate each letter except first #.\n    }\n    if (color.length === 9) { // #rrggbbaa\n      parsedColor = parseInt(color.substr(1), 16);\n    } else if (color.length === 7) { // or #rrggbb.\n      parsedColor = (parseInt(color.substr(1), 16) << 8) | 0xff;\n    } else {\n      throw 'Color expected in hex format with preceding \"#\". E.g. #00ff00. Got value: ' + color;\n    }\n  } else if (typeof color === 'number') {\n    parsedColor = color;\n  }\n\n  return parsedColor;\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglSquare.js":"var parseColor = require('./parseColor.js');\n\nmodule.exports = webglSquare;\n\n/**\n * Can be used as a callback in the webglGraphics.node() function, to\n * create a custom looking node.\n *\n * @param size - size of the node in pixels.\n * @param color - color of the node in '#rrggbbaa' or '#rgb' format.\n */\nfunction webglSquare(size, color) {\n  return {\n    /**\n     * Gets or sets size of the square side.\n     */\n    size: typeof size === 'number' ? size : 10,\n\n    /**\n     * Gets or sets color of the square.\n     */\n    color: parseColor(color)\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/WebGL/webglImage.js":"module.exports = webglImage;\n\n/**\n * Represents a model for image.\n */\nfunction webglImage(size, src) {\n    return {\n        /**\n         * Gets texture index where current image is placed.\n         */\n        _texture : 0,\n\n        /**\n         * Gets offset in the texture where current image is placed.\n         */\n        _offset : 0,\n\n        /**\n         * Gets size of the square with the image.\n         */\n        size : typeof size === 'number' ? size : 32,\n\n        /**\n         * Source of the image. If image is coming not from your domain\n         * certain origin restrictions applies.\n         * See http://www.khronos.org/registry/webgl/specs/latest/#4.2 for more details.\n         */\n        src  : src\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/View/webglGraphics.js":"/**\r\n * @fileOverview Defines a graph renderer that uses WebGL based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\r\n\r\nmodule.exports = webglGraphics;\r\n\r\nvar webglInputManager = require('../Input/webglInputManager.js');\r\nvar webglLinkProgram = require('../WebGL/webglLinkProgram.js');\r\nvar webglNodeProgram = require('../WebGL/webglNodeProgram.js');\r\nvar webglSquare = require('../WebGL/webglSquare.js');\r\nvar webglLine = require('../WebGL/webglLine.js');\r\nvar eventify = require('ngraph.events');\r\nvar merge = require('ngraph.merge');\r\n\r\n/**\r\n * Performs webgl-based graph rendering. This module does not perform\r\n * layout, but only visualizes nodes and edges of the graph.\r\n *\r\n * @param options - to customize graphics  behavior. Currently supported parameter\r\n *  enableBlending - true by default, allows to use transparency in node/links colors.\r\n *  preserveDrawingBuffer - false by default, tells webgl to preserve drawing buffer.\r\n *                    See https://www.khronos.org/registry/webgl/specs/1.0/#5.2\r\n */\r\n\r\nfunction webglGraphics(options) {\r\n    options = merge(options, {\r\n        enableBlending : true,\r\n        preserveDrawingBuffer : false,\r\n        clearColor: false,\r\n        clearColorValue : {\r\n            r : 1,\r\n            g : 1,\r\n            b : 1,\r\n            a : 1\r\n        }\r\n    });\r\n\r\n    var container,\r\n        graphicsRoot,\r\n        gl,\r\n        width,\r\n        height,\r\n        nodesCount = 0,\r\n        linksCount = 0,\r\n        transform = [\r\n            1, 0, 0, 0,\r\n            0, 1, 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1\r\n        ],\r\n        userPlaceNodeCallback,\r\n        userPlaceLinkCallback,\r\n        nodes = [],\r\n        links = [],\r\n        initCallback,\r\n\r\n        allNodes = {},\r\n        allLinks = {},\r\n        linkProgram = webglLinkProgram(),\r\n        nodeProgram = webglNodeProgram(),\r\n/*jshint unused: false */\r\n        nodeUIBuilder = function (node) {\r\n            return webglSquare(); // Just make a square, using provided gl context (a nodeProgram);\r\n        },\r\n\r\n        linkUIBuilder = function (link) {\r\n            return webglLine(0xb3b3b3ff);\r\n        },\r\n/*jshint unused: true */\r\n        updateTransformUniform = function () {\r\n            linkProgram.updateTransform(transform);\r\n            nodeProgram.updateTransform(transform);\r\n        },\r\n\r\n        resetScaleInternal = function () {\r\n            transform = [1, 0, 0, 0,\r\n                        0, 1, 0, 0,\r\n                        0, 0, 1, 0,\r\n                        0, 0, 0, 1];\r\n        },\r\n\r\n        updateSize = function () {\r\n            if (container && graphicsRoot) {\r\n                width = graphicsRoot.width = Math.max(container.offsetWidth, 1);\r\n                height = graphicsRoot.height = Math.max(container.offsetHeight, 1);\r\n                if (gl) { gl.viewport(0, 0, width, height); }\r\n                if (linkProgram) { linkProgram.updateSize(width / 2, height / 2); }\r\n                if (nodeProgram) { nodeProgram.updateSize(width / 2, height / 2); }\r\n            }\r\n        },\r\n\r\n        fireRescaled = function (graphics) {\r\n            graphics.fire(\"rescaled\");\r\n        };\r\n\r\n    graphicsRoot = window.document.createElement(\"canvas\");\r\n\r\n    var graphics = {\r\n        getLinkUI: function (linkId) {\r\n            return allLinks[linkId];\r\n        },\r\n\r\n        getNodeUI: function (nodeId) {\r\n            return allNodes[nodeId];\r\n        },\r\n\r\n        /**\r\n         * Sets the callback that creates node representation.\r\n         *\r\n         * @param builderCallback a callback function that accepts graph node\r\n         * as a parameter and must return an element representing this node.\r\n         *\r\n         * @returns If builderCallbackOrNode is a valid callback function, instance of this is returned;\r\n         * Otherwise undefined value is returned\r\n         */\r\n        node : function (builderCallback) {\r\n            if (typeof builderCallback !== \"function\") {\r\n                return; // todo: throw? This is not compatible with old versions\r\n            }\r\n\r\n            nodeUIBuilder = builderCallback;\r\n\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Sets the callback that creates link representation\r\n         *\r\n         * @param builderCallback a callback function that accepts graph link\r\n         * as a parameter and must return an element representing this link.\r\n         *\r\n         * @returns If builderCallback is a valid callback function, instance of this is returned;\r\n         * Otherwise undefined value is returned.\r\n         */\r\n        link : function (builderCallback) {\r\n            if (typeof builderCallback !== \"function\") {\r\n                return; // todo: throw? This is not compatible with old versions\r\n            }\r\n\r\n            linkUIBuilder = builderCallback;\r\n            return this;\r\n        },\r\n\r\n\r\n        /**\r\n         * Allows to override default position setter for the node with a new\r\n         * function. newPlaceCallback(nodeUI, position) is function which\r\n         * is used by updateNodePosition().\r\n         */\r\n        placeNode : function (newPlaceCallback) {\r\n            userPlaceNodeCallback = newPlaceCallback;\r\n            return this;\r\n        },\r\n\r\n        placeLink : function (newPlaceLinkCallback) {\r\n            userPlaceLinkCallback = newPlaceLinkCallback;\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Custom input manager listens to mouse events to process nodes drag-n-drop inside WebGL canvas\r\n         */\r\n        inputManager : webglInputManager,\r\n\r\n        /**\r\n         * Called every time before renderer starts rendering.\r\n         */\r\n        beginRender : function () {\r\n            // this function could be replaced by this.init,\r\n            // based on user options.\r\n        },\r\n\r\n        /**\r\n         * Called every time when renderer finishes one step of rendering.\r\n         */\r\n        endRender : function () {\r\n            if (linksCount > 0) {\r\n                linkProgram.render();\r\n            }\r\n            if (nodesCount > 0) {\r\n                nodeProgram.render();\r\n            }\r\n        },\r\n\r\n        bringLinkToFront : function (linkUI) {\r\n            var frontLinkId = linkProgram.getFrontLinkId(),\r\n                srcLinkId,\r\n                temp;\r\n\r\n            linkProgram.bringToFront(linkUI);\r\n\r\n            if (frontLinkId > linkUI.id) {\r\n                srcLinkId = linkUI.id;\r\n\r\n                temp = links[frontLinkId];\r\n                links[frontLinkId] = links[srcLinkId];\r\n                links[frontLinkId].id = frontLinkId;\r\n                links[srcLinkId] = temp;\r\n                links[srcLinkId].id = srcLinkId;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets translate operation that should be applied to all nodes and links.\r\n         */\r\n        graphCenterChanged : function (x, y) {\r\n            transform[12] = (2 * x / width) - 1;\r\n            transform[13] = 1 - (2 * y / height);\r\n            updateTransformUniform();\r\n        },\r\n\r\n        /**\r\n         * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n         * provider prepare to render given link of the graph\r\n         *\r\n         * @param link - model of a link\r\n         */\r\n        addLink: function (link, boundPosition) {\r\n            var uiid = linksCount++,\r\n                ui = linkUIBuilder(link);\r\n            ui.id = uiid;\r\n            ui.pos = boundPosition;\r\n\r\n            linkProgram.createLink(ui);\r\n\r\n            links[uiid] = ui;\r\n            allLinks[link.id] = ui;\r\n            return ui;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider prepare to render given node of the graph.\r\n        *\r\n        * @param nodeUI visual representation of the node created by node() execution.\r\n        **/\r\n        addNode : function (node, boundPosition) {\r\n            var uiid = nodesCount++,\r\n                ui = nodeUIBuilder(node);\r\n\r\n            ui.id = uiid;\r\n            ui.position = boundPosition;\r\n            ui.node = node;\r\n\r\n            nodeProgram.createNode(ui);\r\n\r\n            nodes[uiid] = ui;\r\n            allNodes[node.id] = ui;\r\n            return ui;\r\n        },\r\n\r\n        translateRel : function (dx, dy) {\r\n            transform[12] += (2 * transform[0] * dx / width) / transform[0];\r\n            transform[13] -= (2 * transform[5] * dy / height) / transform[5];\r\n            updateTransformUniform();\r\n        },\r\n\r\n        scale : function (scaleFactor, scrollPoint) {\r\n            // Transform scroll point to clip-space coordinates:\r\n            var cx = 2 * scrollPoint.x / width - 1,\r\n                cy = 1 - (2 * scrollPoint.y) / height;\r\n\r\n            cx -= transform[12];\r\n            cy -= transform[13];\r\n\r\n            transform[12] += cx * (1 - scaleFactor);\r\n            transform[13] += cy * (1 - scaleFactor);\r\n\r\n            transform[0] *= scaleFactor;\r\n            transform[5] *= scaleFactor;\r\n\r\n            updateTransformUniform();\r\n            fireRescaled(this);\r\n\r\n            return transform[0];\r\n        },\r\n\r\n        resetScale : function () {\r\n            resetScaleInternal();\r\n\r\n            if (gl) {\r\n                updateSize();\r\n                // TODO: what is this?\r\n                // gl.useProgram(linksProgram);\r\n                // gl.uniform2f(linksProgram.screenSize, width, height);\r\n                updateTransformUniform();\r\n            }\r\n            return this;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider prepare to render.\r\n        */\r\n        init : function (c) {\r\n            var contextParameters = {};\r\n\r\n            if (options.preserveDrawingBuffer) {\r\n                contextParameters.preserveDrawingBuffer = true;\r\n            }\r\n\r\n            container = c;\r\n\r\n            updateSize();\r\n            resetScaleInternal();\r\n            container.appendChild(graphicsRoot);\r\n\r\n\r\n            gl = graphicsRoot.getContext(\"experimental-webgl\", contextParameters);\r\n            if (!gl) {\r\n                var msg = \"Could not initialize WebGL. Seems like the browser doesn't support it.\";\r\n                window.alert(msg);\r\n                throw msg;\r\n            }\r\n            if (options.enableBlending) {\r\n                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n                gl.enable(gl.BLEND);\r\n            }\r\n            if (options.clearColor) {\r\n                var color = options.clearColorValue;\r\n                gl.clearColor(color.r, color.g, color.b, color.a);\r\n                // TODO: not the best way, really. Should come up with something better\r\n                // what if we need more updates inside beginRender, like depth buffer?\r\n                this.beginRender = function () {\r\n                    gl.clear(gl.COLOR_BUFFER_BIT);\r\n                };\r\n            }\r\n\r\n            linkProgram.load(gl);\r\n            linkProgram.updateSize(width / 2, height / 2);\r\n\r\n            nodeProgram.load(gl);\r\n            nodeProgram.updateSize(width / 2, height / 2);\r\n\r\n            updateTransformUniform();\r\n\r\n            // Notify the world if someone waited for update. TODO: should send an event\r\n            if (typeof initCallback === \"function\") {\r\n                initCallback(graphicsRoot);\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider release occupied resources.\r\n        */\r\n        release : function (container) {\r\n            if (graphicsRoot && container) {\r\n                container.removeChild(graphicsRoot);\r\n                // TODO: anything else?\r\n            }\r\n        },\r\n\r\n       /**\r\n        * Checks whether webgl is supported by this browser.\r\n        */\r\n        isSupported : function () {\r\n            var c = window.document.createElement(\"canvas\"),\r\n                gl = c && c.getContext && c.getContext(\"experimental-webgl\");\r\n            return gl;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider remove link from rendering surface.\r\n        *\r\n        * @param linkUI visual representation of the link created by link() execution.\r\n        **/\r\n        releaseLink : function (link) {\r\n            if (linksCount > 0) { linksCount -= 1; }\r\n            var linkUI = allLinks[link.id];\r\n            delete allLinks[link.id];\r\n\r\n            linkProgram.removeLink(linkUI);\r\n\r\n            var linkIdToRemove = linkUI.id;\r\n            if (linkIdToRemove < linksCount) {\r\n                if (linksCount === 0 || linksCount === linkIdToRemove) {\r\n                    return; // no more links or removed link is the last one.\r\n                }\r\n\r\n                var lastLinkUI = links[linksCount];\r\n                links[linkIdToRemove] = lastLinkUI;\r\n                lastLinkUI.id = linkIdToRemove;\r\n            }\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider remove node from rendering surface.\r\n        *\r\n        * @param nodeUI visual representation of the node created by node() execution.\r\n        **/\r\n        releaseNode : function (node) {\r\n            if (nodesCount > 0) { nodesCount -= 1; }\r\n            var nodeUI = allNodes[node.id];\r\n            delete allNodes[node.id];\r\n\r\n            nodeProgram.removeNode(nodeUI);\r\n\r\n            var nodeIdToRemove = nodeUI.id;\r\n            if (nodeIdToRemove < nodesCount) {\r\n                if (nodesCount === 0 || nodesCount === nodeIdToRemove) {\r\n                    return; // no more nodes or removed node is the last in the list.\r\n                }\r\n\r\n                var lastNodeUI = nodes[nodesCount];\r\n\r\n                nodes[nodeIdToRemove] = lastNodeUI;\r\n                lastNodeUI.id = nodeIdToRemove;\r\n\r\n                // Since concrete shaders may cache properties in the UI element\r\n                // we are letting them to make this swap (e.g. image node shader\r\n                // uses this approach to update node's offset in the atlas)\r\n                nodeProgram.replaceProperties(nodeUI, lastNodeUI);\r\n            }\r\n        },\r\n\r\n        renderNodes: function () {\r\n            var pos = {x : 0, y : 0};\r\n            // WebGL coordinate system is different. Would be better\r\n            // to have this transform in the shader code, but it would\r\n            // require every shader to be updated..\r\n            for (var i = 0; i < nodesCount; ++i) {\r\n                var ui = nodes[i];\r\n                pos.x = ui.position.x;\r\n                pos.y = ui.position.y;\r\n                if (userPlaceNodeCallback) {\r\n                    userPlaceNodeCallback(ui, pos);\r\n                }\r\n\r\n                nodeProgram.position(ui, pos);\r\n            }\r\n        },\r\n\r\n        renderLinks: function () {\r\n            if (this.omitLinksRendering) { return; }\r\n\r\n            var toPos = {x : 0, y : 0};\r\n            var fromPos = {x : 0, y : 0};\r\n            for (var i = 0; i < linksCount; ++i) {\r\n                var ui = links[i];\r\n                var pos = ui.pos.from;\r\n                fromPos.x = pos.x;\r\n                fromPos.y = -pos.y;\r\n                pos = ui.pos.to;\r\n                toPos.x = pos.x;\r\n                toPos.y = -pos.y;\r\n                if (userPlaceLinkCallback) {\r\n                    userPlaceLinkCallback(ui, fromPos, toPos);\r\n                }\r\n\r\n                linkProgram.position(ui, fromPos, toPos);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns root element which hosts graphics.\r\n         */\r\n        getGraphicsRoot : function (callbackWhenReady) {\r\n            // todo: should fire an event, instead of having this context.\r\n            if (typeof callbackWhenReady === \"function\") {\r\n                if (graphicsRoot) {\r\n                    callbackWhenReady(graphicsRoot);\r\n                } else {\r\n                    initCallback = callbackWhenReady;\r\n                }\r\n            }\r\n            return graphicsRoot;\r\n        },\r\n\r\n        /**\r\n         * Updates default shader which renders nodes\r\n         *\r\n         * @param newProgram to use for nodes.\r\n         */\r\n        setNodeProgram : function (newProgram) {\r\n            if (!gl && newProgram) {\r\n                // Nothing created yet. Just set shader to the new one\r\n                // and let initialization logic take care about the rest.\r\n                nodeProgram = newProgram;\r\n            } else if (newProgram) {\r\n                throw \"Not implemented. Cannot swap shader on the fly... Yet.\";\r\n                // TODO: unload old shader and reinit.\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Updates default shader which renders links\r\n         *\r\n         * @param newProgram to use for links.\r\n         */\r\n        setLinkProgram : function (newProgram) {\r\n            if (!gl && newProgram) {\r\n                // Nothing created yet. Just set shader to the new one\r\n                // and let initialization logic take care about the rest.\r\n                linkProgram = newProgram;\r\n            } else if (newProgram) {\r\n                throw \"Not implemented. Cannot swap shader on the fly... Yet.\";\r\n                // TODO: unload old shader and reinit.\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Transforms client coordinates into layout coordinates. Client coordinates\r\n         * are DOM coordinates relative to the rendering container. Layout\r\n         * coordinates are those assigned by by layout algorithm to each node.\r\n         *\r\n         * @param {Object} p - a point object with `x` and `y` attributes.\r\n         * This method mutates p.\r\n         */\r\n        transformClientToGraphCoordinates: function (p) {\r\n          // TODO: could be a problem when container has margins?\r\n            // normalize\r\n            p.x = ((2 * p.x) / width) - 1;\r\n            p.y = 1 - ((2 * p.y) / height);\r\n\r\n            // apply transform\r\n            p.x = (p.x - transform[12]) / transform[0];\r\n            p.y = (p.y - transform[13]) / transform[5];\r\n\r\n            // transform to graph coordinates\r\n            p.x = p.x * (width / 2);\r\n            p.y = p.y * (-height / 2);\r\n\r\n            return p;\r\n        },\r\n\r\n        /**\r\n         * Transforms WebGL coordinates into client coordinates. Reverse of \r\n         * `transformClientToGraphCoordinates()`\r\n         *\r\n         * @param {Object} p - a point object with `x` and `y` attributes, which\r\n         * represents a layout coordinate. This method mutates p.\r\n         */\r\n        transformGraphToClientCoordinates: function (p) {\r\n          // TODO: could be a problem when container has margins?\r\n            // transform from graph coordinates\r\n            p.x = p.x / (width / 2);\r\n            p.y = p.y / (-height / 2);\r\n\r\n            // apply transform\r\n            p.x = (p.x * transform[0]) + transform[12];\r\n            p.y = (p.y * transform[5]) + transform[13];\r\n\r\n            // denormalize\r\n            p.x = ((p.x + 1) * width) / 2;\r\n            p.y = ((1 - p.y) * height) / 2;\r\n\r\n            return p;\r\n        },\r\n\r\n        getNodeAtClientPos: function (clientPos, preciseCheck) {\r\n            if (typeof preciseCheck !== \"function\") {\r\n                // we don't know anything about your node structure here :(\r\n                // potentially this could be delegated to node program, but for\r\n                // right now, we are giving up if you don't pass boundary check\r\n                // callback. It answers to a question is nodeUI covers  (x, y)\r\n                return null;\r\n            }\r\n            // first transform to graph coordinates:\r\n            this.transformClientToGraphCoordinates(clientPos);\r\n            // now using precise check iterate over each node and find one within box:\r\n            // TODO: This is poor O(N) performance.\r\n            for (var i = 0; i < nodesCount; ++i) {\r\n                if (preciseCheck(nodes[i], clientPos.x, clientPos.y)) {\r\n                    return nodes[i].node;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n\r\n    // Let graphics fire events before we return it to the caller.\r\n    eventify(graphics);\r\n\r\n    return graphics;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/View/svgGraphics.js":"/**\r\n * @fileOverview Defines a graph renderer that uses SVG based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / http://anvaka.blogspot.com\r\n */\r\n\r\nmodule.exports = svgGraphics;\r\n\r\nvar svg = require('simplesvg');\r\nvar eventify = require('ngraph.events');\r\nvar domInputManager = require('../Input/domInputManager.js');\r\n\r\n/**\r\n * Performs svg-based graph rendering. This module does not perform\r\n * layout, but only visualizes nodes and edges of the graph.\r\n */\r\nfunction svgGraphics() {\r\n    var svgContainer,\r\n        svgRoot,\r\n        offsetX = 0,\r\n        offsetY = 0,\r\n        initCallback,\r\n        actualScale = 1,\r\n        allNodes = {},\r\n        allLinks = {},\r\n/*jshint unused: false */\r\n        nodeBuilder = function (node) {\r\n            return svg(\"rect\")\r\n                     .attr(\"width\", 10)\r\n                     .attr(\"height\", 10)\r\n                     .attr(\"fill\", \"#00a2e8\");\r\n        },\r\n\r\n        nodePositionCallback = function (nodeUI, pos) {\r\n            // TODO: Remove magic 5. It should be half of the width or height of the node.\r\n            nodeUI.attr(\"x\", pos.x - 5)\r\n                  .attr(\"y\", pos.y - 5);\r\n        },\r\n\r\n        linkBuilder = function (link) {\r\n            return svg(\"line\").attr(\"stroke\", \"#999\");\r\n        },\r\n\r\n        linkPositionCallback = function (linkUI, fromPos, toPos) {\r\n            linkUI.attr(\"x1\", fromPos.x)\r\n                  .attr(\"y1\", fromPos.y)\r\n                  .attr(\"x2\", toPos.x)\r\n                  .attr(\"y2\", toPos.y);\r\n        },\r\n\r\n        fireRescaled = function (graphics) {\r\n            // TODO: maybe we shall copy changes?\r\n            graphics.fire(\"rescaled\");\r\n        },\r\n\r\n        cachedPos = {x : 0, y: 0},\r\n        cachedFromPos = {x : 0, y: 0},\r\n        cachedToPos = {x : 0, y: 0},\r\n\r\n        updateTransform = function () {\r\n            if (svgContainer) {\r\n                var transform = \"matrix(\" + actualScale + \", 0, 0,\" + actualScale + \",\" + offsetX + \",\" + offsetY + \")\";\r\n                svgContainer.attr(\"transform\", transform);\r\n            }\r\n        };\r\n\r\n    svgRoot = createSvgRoot();\r\n\r\n    var graphics = {\r\n        getNodeUI: function (nodeId) {\r\n            return allNodes[nodeId];\r\n        },\r\n\r\n        getLinkUI: function (linkId) {\r\n            return allLinks[linkId];\r\n        },\r\n\r\n        /**\r\n         * Sets the callback that creates node representation.\r\n         *\r\n         * @param builderCallback a callback function that accepts graph node\r\n         * as a parameter and must return an element representing this node.\r\n         *\r\n         * @returns If builderCallbackOrNode is a valid callback function, instance of this is returned;\r\n         * Otherwise undefined value is returned\r\n         */\r\n        node : function (builderCallback) {\r\n            if (typeof builderCallback !== \"function\") {\r\n                return; // todo: throw? This is not compatible with old versions\r\n            }\r\n\r\n            nodeBuilder = builderCallback;\r\n\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Sets the callback that creates link representation\r\n         *\r\n         * @param builderCallback a callback function that accepts graph link\r\n         * as a parameter and must return an element representing this link.\r\n         *\r\n         * @returns If builderCallback is a valid callback function, instance of this is returned;\r\n         * Otherwise undefined value is returned.\r\n         */\r\n        link : function (builderCallback) {\r\n            if (typeof builderCallback !== \"function\") {\r\n                return; // todo: throw? This is not compatible with old versions\r\n            }\r\n\r\n            linkBuilder = builderCallback;\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Allows to override default position setter for the node with a new\r\n         * function. newPlaceCallback(nodeUI, position, node) is function which\r\n         * is used by updateNodePosition().\r\n         */\r\n        placeNode : function (newPlaceCallback) {\r\n            nodePositionCallback = newPlaceCallback;\r\n            return this;\r\n        },\r\n\r\n        placeLink : function (newPlaceLinkCallback) {\r\n            linkPositionCallback = newPlaceLinkCallback;\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Called every before renderer starts rendering.\r\n         */\r\n        beginRender : function () {},\r\n\r\n        /**\r\n         * Called every time when renderer finishes one step of rendering.\r\n         */\r\n        endRender : function () {},\r\n\r\n        /**\r\n         * Sets translate operation that should be applied to all nodes and links.\r\n         */\r\n        graphCenterChanged : function (x, y) {\r\n            offsetX = x;\r\n            offsetY = y;\r\n            updateTransform();\r\n        },\r\n\r\n        /**\r\n         * Default input manager listens to DOM events to process nodes drag-n-drop\r\n         */\r\n        inputManager : domInputManager,\r\n\r\n        translateRel : function (dx, dy) {\r\n            var p = svgRoot.createSVGPoint(),\r\n                t = svgContainer.getCTM(),\r\n                origin = svgRoot.createSVGPoint().matrixTransform(t.inverse());\r\n\r\n            p.x = dx;\r\n            p.y = dy;\r\n\r\n            p = p.matrixTransform(t.inverse());\r\n            p.x = (p.x - origin.x) * t.a;\r\n            p.y = (p.y - origin.y) * t.d;\r\n\r\n            t.e += p.x;\r\n            t.f += p.y;\r\n\r\n            var transform = \"matrix(\" + t.a + \", 0, 0,\" + t.d + \",\" + t.e + \",\" + t.f + \")\";\r\n            svgContainer.attr(\"transform\", transform);\r\n        },\r\n\r\n        scale : function (scaleFactor, scrollPoint) {\r\n            var p = svgRoot.createSVGPoint();\r\n            p.x = scrollPoint.x;\r\n            p.y = scrollPoint.y;\r\n\r\n            p = p.matrixTransform(svgContainer.getCTM().inverse()); // translate to SVG coordinates\r\n\r\n            // Compute new scale matrix in current mouse position\r\n            var k = svgRoot.createSVGMatrix().translate(p.x, p.y).scale(scaleFactor).translate(-p.x, -p.y),\r\n                t = svgContainer.getCTM().multiply(k);\r\n\r\n            actualScale = t.a;\r\n            offsetX = t.e;\r\n            offsetY = t.f;\r\n            var transform = \"matrix(\" + t.a + \", 0, 0,\" + t.d + \",\" + t.e + \",\" + t.f + \")\";\r\n            svgContainer.attr(\"transform\", transform);\r\n\r\n            fireRescaled(this);\r\n            return actualScale;\r\n        },\r\n\r\n        resetScale : function () {\r\n            actualScale = 1;\r\n            var transform = \"matrix(1, 0, 0, 1, 0, 0)\";\r\n            svgContainer.attr(\"transform\", transform);\r\n            fireRescaled(this);\r\n            return this;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider prepare to render.\r\n        */\r\n        init : function (container) {\r\n            container.appendChild(svgRoot);\r\n            updateTransform();\r\n            // Notify the world if someone waited for update. TODO: should send an event\r\n            if (typeof initCallback === \"function\") {\r\n                initCallback(svgRoot);\r\n            }\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider release occupied resources.\r\n        */\r\n        release : function (container) {\r\n            if (svgRoot && container) {\r\n                container.removeChild(svgRoot);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n         * provider prepare to render given link of the graph\r\n         *\r\n         * @param link - model of a link\r\n         */\r\n        addLink: function (link, pos) {\r\n            var linkUI = linkBuilder(link);\r\n            if (!linkUI) { return; }\r\n            linkUI.position = pos;\r\n            linkUI.link = link;\r\n            allLinks[link.id] = linkUI;\r\n            if (svgContainer.childElementCount > 0) {\r\n                svgContainer.insertBefore(linkUI, svgContainer.firstChild);\r\n            } else {\r\n                svgContainer.appendChild(linkUI);\r\n            }\r\n            return linkUI;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider remove link from rendering surface.\r\n        *\r\n        * @param linkUI visual representation of the link created by link() execution.\r\n        **/\r\n        releaseLink : function (link) {\r\n            var linkUI = allLinks[link.id];\r\n            if (linkUI) {\r\n                svgContainer.removeChild(linkUI);\r\n                delete allLinks[link.id];\r\n            }\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider prepare to render given node of the graph.\r\n        *\r\n        * @param nodeUI visual representation of the node created by node() execution.\r\n        **/\r\n        addNode : function (node, pos) {\r\n            var nodeUI = nodeBuilder(node);\r\n            if (!nodeUI) {\r\n                return;\r\n            }\r\n            nodeUI.position = pos;\r\n            nodeUI.node = node;\r\n            allNodes[node.id] = nodeUI;\r\n\r\n            svgContainer.appendChild(nodeUI);\r\n\r\n            return nodeUI;\r\n        },\r\n\r\n       /**\r\n        * Called by Viva.Graph.View.renderer to let concrete graphic output\r\n        * provider remove node from rendering surface.\r\n        *\r\n        * @param node graph's node\r\n        **/\r\n        releaseNode : function (node) {\r\n            var nodeUI = allNodes[node.id];\r\n            if (nodeUI) {\r\n                svgContainer.removeChild(nodeUI);\r\n                delete allNodes[node.id];\r\n            }\r\n        },\r\n\r\n        renderNodes : function () {\r\n            for (var key in allNodes) {\r\n                if (allNodes.hasOwnProperty(key)) {\r\n                    var nodeUI = allNodes[key];\r\n                    cachedPos.x = nodeUI.position.x;\r\n                    cachedPos.y = nodeUI.position.y;\r\n                    nodePositionCallback(nodeUI, cachedPos, nodeUI.node);\r\n                }\r\n            }\r\n        },\r\n\r\n        renderLinks : function () {\r\n            for (var key in allLinks) {\r\n                if (allLinks.hasOwnProperty(key)) {\r\n                    var linkUI = allLinks[key];\r\n                    cachedFromPos.x = linkUI.position.from.x;\r\n                    cachedFromPos.y = linkUI.position.from.y;\r\n                    cachedToPos.x = linkUI.position.to.x;\r\n                    cachedToPos.y = linkUI.position.to.y;\r\n                    linkPositionCallback(linkUI, cachedFromPos, cachedToPos, linkUI.link);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns root element which hosts graphics.\r\n         */\r\n        getGraphicsRoot : function (callbackWhenReady) {\r\n            // todo: should fire an event, instead of having this context.\r\n            if (typeof callbackWhenReady === \"function\") {\r\n                if (svgRoot) {\r\n                    callbackWhenReady(svgRoot);\r\n                } else {\r\n                    initCallback = callbackWhenReady;\r\n                }\r\n            }\r\n            return svgRoot;\r\n        },\r\n        /**\r\n         * Returns root SVG element.\r\n         *\r\n         * Note: This is internal method specific to this renderer\r\n         */\r\n        getSvgRoot : function () {\r\n            return svgRoot;\r\n        }\r\n    };\r\n\r\n\r\n    // Let graphics fire events before we return it to the caller.\r\n    eventify(graphics);\r\n\r\n    return graphics;\r\n\r\n    function createSvgRoot() {\r\n        var svgRoot = svg(\"svg\");\r\n\r\n        svgContainer = svg(\"g\")\r\n              .attr(\"buffered-rendering\", \"dynamic\");\r\n\r\n        svgRoot.appendChild(svgContainer);\r\n        return svgRoot;\r\n    }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/View/renderer.js":"/**\r\n * @fileOverview Defines a graph renderer that uses CSS based drawings.\r\n *\r\n * @author Andrei Kashcha (aka anvaka) / https://github.com/anvaka\r\n */\r\n\r\nmodule.exports = renderer;\r\n\r\nvar eventify = require('ngraph.events');\r\nvar forceDirected = require('ngraph.forcelayout');\r\nvar svgGraphics = require('./svgGraphics.js');\r\nvar windowEvents = require('../Utils/windowEvents.js');\r\nvar domInputManager = require('../Input/domInputManager.js');\r\nvar timer = require('../Utils/timer.js');\r\nvar getDimension = require('../Utils/getDimensions.js');\r\nvar dragndrop = require('../Input/dragndrop.js');\r\n\r\n/**\r\n * This is heart of the rendering. Class accepts graph to be rendered and rendering settings.\r\n * It monitors graph changes and depicts them accordingly.\r\n *\r\n * @param graph - Viva.Graph.graph() object to be rendered.\r\n * @param settings - rendering settings, composed from the following parts (with their defaults shown):\r\n *   settings = {\r\n *     // Represents a module that is capable of displaying graph nodes and links.\r\n *     // all graphics has to correspond to defined interface and can be later easily\r\n *     // replaced for specific needs (e.g. adding WebGL should be piece of cake as long\r\n *     // as WebGL has implemented required interface). See svgGraphics for example.\r\n *     graphics : Viva.Graph.View.svgGraphics(),\r\n *\r\n *     // Where the renderer should draw graph. Container size matters, because\r\n *     // renderer will attempt center graph to that size. Also graphics modules\r\n *     // might depend on it.\r\n *     container : document.body,\r\n *\r\n *     // Defines whether graph can respond to use input\r\n *     interactive: true,\r\n *\r\n *     // Layout algorithm to be used. The algorithm is expected to comply with defined\r\n *     // interface and is expected to be iterative. Renderer will use it then to calculate\r\n *     // grpaph's layout. For examples of the interface refer to Viva.Graph.Layout.forceDirected()\r\n *     layout : Viva.Graph.Layout.forceDirected(),\r\n *\r\n *     // Directs renderer to display links. Usually rendering links is the slowest part of this\r\n *     // library. So if you don't need to display links, consider settings this property to false.\r\n *     renderLinks : true,\r\n *\r\n *     // Number of layout iterations to run before displaying the graph. The bigger you set this number\r\n *     // the closer to ideal position graph will appear first time. But be careful: for large graphs\r\n *     // it can freeze the browser.\r\n *     prerender : 0\r\n *   }\r\n */\r\nfunction renderer(graph, settings) {\r\n  // TODO: This class is getting hard to understand. Consider refactoring.\r\n  // TODO: I have a technical debt here: fix scaling/recentering! Currently it's a total mess.\r\n  var FRAME_INTERVAL = 30;\r\n\r\n  settings = settings || {};\r\n\r\n  var layout = settings.layout,\r\n    graphics = settings.graphics,\r\n    container = settings.container,\r\n    interactive = settings.interactive !== undefined ? settings.interactive : true,\r\n    inputManager,\r\n    animationTimer,\r\n    rendererInitialized = false,\r\n    updateCenterRequired = true,\r\n\r\n    currentStep = 0,\r\n    totalIterationsCount = 0,\r\n    isStable = false,\r\n    userInteraction = false,\r\n    isPaused = false,\r\n\r\n    transform = {\r\n      offsetX: 0,\r\n      offsetY: 0,\r\n      scale: 1\r\n    },\r\n\r\n    publicEvents = eventify({}),\r\n    containerDrag;\r\n\r\n  return {\r\n    /**\r\n     * Performs rendering of the graph.\r\n     *\r\n     * @param iterationsCount if specified renderer will run only given number of iterations\r\n     * and then stop. Otherwise graph rendering is performed infinitely.\r\n     *\r\n     * Note: if rendering stopped by used started dragging nodes or new nodes were added to the\r\n     * graph renderer will give run more iterations to reflect changes.\r\n     */\r\n    run: function(iterationsCount) {\r\n\r\n      if (!rendererInitialized) {\r\n        prepareSettings();\r\n        prerender();\r\n\r\n        initDom();\r\n        updateCenter();\r\n        listenToEvents();\r\n\r\n        rendererInitialized = true;\r\n      }\r\n\r\n      renderIterations(iterationsCount);\r\n\r\n      return this;\r\n    },\r\n\r\n    reset: function() {\r\n      graphics.resetScale();\r\n      updateCenter();\r\n      transform.scale = 1;\r\n    },\r\n\r\n    pause: function() {\r\n      isPaused = true;\r\n      animationTimer.stop();\r\n    },\r\n\r\n    resume: function() {\r\n      isPaused = false;\r\n      animationTimer.restart();\r\n    },\r\n\r\n    rerender: function() {\r\n      renderGraph();\r\n      return this;\r\n    },\r\n\r\n    zoomOut: function() {\r\n      return scale(true);\r\n    },\r\n\r\n    zoomIn: function() {\r\n      return scale(false);\r\n    },\r\n\r\n    /**\r\n     * Centers renderer at x,y graph's coordinates\r\n     */\r\n    moveTo: function(x, y) {\r\n      graphics.graphCenterChanged(transform.offsetX - x * transform.scale, transform.offsetY - y * transform.scale);\r\n      renderGraph();\r\n    },\r\n\r\n    /**\r\n     * Gets current graphics object\r\n     */\r\n    getGraphics: function() {\r\n      return graphics;\r\n    },\r\n\r\n    /**\r\n     * Removes this renderer and deallocates all resources/timers\r\n     */\r\n    dispose: function() {\r\n      stopListenToEvents(); // I quit!\r\n    },\r\n\r\n    on: function(eventName, callback) {\r\n      publicEvents.on(eventName, callback);\r\n      return this;\r\n    },\r\n\r\n    off: function(eventName, callback) {\r\n      publicEvents.off(eventName, callback);\r\n      return this;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Checks whether given interaction (node/scroll) is enabled\r\n   */\r\n  function isInteractive(interactionName) {\r\n    if (typeof interactive === 'string') {\r\n      return interactive.indexOf(interactionName) >= 0;\r\n    } else if (typeof interactive === 'boolean') {\r\n      return interactive;\r\n    }\r\n    return true; // default setting\r\n  }\r\n\r\n  function prepareSettings() {\r\n    container = container || window.document.body;\r\n    layout = layout || forceDirected(graph, {\r\n      springLength: 80,\r\n      springCoeff: 0.0002,\r\n    });\r\n    graphics = graphics || svgGraphics(graph, {\r\n      container: container\r\n    });\r\n\r\n    if (!settings.hasOwnProperty('renderLinks')) {\r\n      settings.renderLinks = true;\r\n    }\r\n\r\n    settings.prerender = settings.prerender || 0;\r\n    inputManager = (graphics.inputManager || domInputManager)(graph, graphics);\r\n  }\r\n\r\n  function renderGraph() {\r\n    graphics.beginRender();\r\n\r\n    // todo: move this check graphics\r\n    if (settings.renderLinks) {\r\n      graphics.renderLinks();\r\n    }\r\n    graphics.renderNodes();\r\n    graphics.endRender();\r\n  }\r\n\r\n  function onRenderFrame() {\r\n    isStable = layout.step() && !userInteraction;\r\n    renderGraph();\r\n\r\n    return !isStable;\r\n  }\r\n\r\n  function renderIterations(iterationsCount) {\r\n    if (animationTimer) {\r\n      totalIterationsCount += iterationsCount;\r\n      return;\r\n    }\r\n\r\n    if (iterationsCount) {\r\n      totalIterationsCount += iterationsCount;\r\n\r\n      animationTimer = timer(function() {\r\n        return onRenderFrame();\r\n      }, FRAME_INTERVAL);\r\n    } else {\r\n      currentStep = 0;\r\n      totalIterationsCount = 0;\r\n      animationTimer = timer(onRenderFrame, FRAME_INTERVAL);\r\n    }\r\n  }\r\n\r\n  function resetStable() {\r\n    if (isPaused) {\r\n      return;\r\n    }\r\n\r\n    isStable = false;\r\n    animationTimer.restart();\r\n  }\r\n\r\n  function prerender() {\r\n    // To get good initial positions for the graph\r\n    // perform several prerender steps in background.\r\n    if (typeof settings.prerender === 'number' && settings.prerender > 0) {\r\n      for (var i = 0; i < settings.prerender; i += 1) {\r\n        layout.step();\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateCenter() {\r\n    var graphRect = layout.getGraphRect(),\r\n      containerSize = getDimension(container);\r\n\r\n    var cx = (graphRect.x2 + graphRect.x1) / 2;\r\n    var cy = (graphRect.y2 + graphRect.y1) / 2;\r\n    transform.offsetX = containerSize.width / 2 - (cx * transform.scale - cx);\r\n    transform.offsetY = containerSize.height / 2 - (cy * transform.scale - cy);\r\n    graphics.graphCenterChanged(transform.offsetX, transform.offsetY);\r\n\r\n    updateCenterRequired = false;\r\n  }\r\n\r\n  function createNodeUi(node) {\r\n    var nodePosition = layout.getNodePosition(node.id);\r\n    graphics.addNode(node, nodePosition);\r\n  }\r\n\r\n  function removeNodeUi(node) {\r\n    graphics.releaseNode(node);\r\n  }\r\n\r\n  function createLinkUi(link) {\r\n    var linkPosition = layout.getLinkPosition(link.id);\r\n    graphics.addLink(link, linkPosition);\r\n  }\r\n\r\n  function removeLinkUi(link) {\r\n    graphics.releaseLink(link);\r\n  }\r\n\r\n  function listenNodeEvents(node) {\r\n    if (!isInteractive('node')) {\r\n      return;\r\n    }\r\n\r\n    var wasPinned = false;\r\n\r\n    // TODO: This may not be memory efficient. Consider reusing handlers object.\r\n    inputManager.bindDragNDrop(node, {\r\n      onStart: function() {\r\n        wasPinned = layout.isNodePinned(node);\r\n        layout.pinNode(node, true);\r\n        userInteraction = true;\r\n        resetStable();\r\n      },\r\n      onDrag: function(e, offset) {\r\n        var oldPos = layout.getNodePosition(node.id);\r\n        layout.setNodePosition(node.id,\r\n          oldPos.x + offset.x / transform.scale,\r\n          oldPos.y + offset.y / transform.scale);\r\n\r\n        userInteraction = true;\r\n\r\n        renderGraph();\r\n      },\r\n      onStop: function() {\r\n        layout.pinNode(node, wasPinned);\r\n        userInteraction = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  function releaseNodeEvents(node) {\r\n    inputManager.bindDragNDrop(node, null);\r\n  }\r\n\r\n  function initDom() {\r\n    graphics.init(container);\r\n\r\n    graph.forEachNode(createNodeUi);\r\n\r\n    if (settings.renderLinks) {\r\n      graph.forEachLink(createLinkUi);\r\n    }\r\n  }\r\n\r\n  function releaseDom() {\r\n    graphics.release(container);\r\n  }\r\n\r\n  function processNodeChange(change) {\r\n    var node = change.node;\r\n\r\n    if (change.changeType === 'add') {\r\n      createNodeUi(node);\r\n      listenNodeEvents(node);\r\n      if (updateCenterRequired) {\r\n        updateCenter();\r\n      }\r\n    } else if (change.changeType === 'remove') {\r\n      releaseNodeEvents(node);\r\n      removeNodeUi(node);\r\n      if (graph.getNodesCount() === 0) {\r\n        updateCenterRequired = true; // Next time when node is added - center the graph.\r\n      }\r\n    } else if (change.changeType === 'update') {\r\n      releaseNodeEvents(node);\r\n      removeNodeUi(node);\r\n\r\n      createNodeUi(node);\r\n      listenNodeEvents(node);\r\n    }\r\n  }\r\n\r\n  function processLinkChange(change) {\r\n    var link = change.link;\r\n    if (change.changeType === 'add') {\r\n      if (settings.renderLinks) {\r\n        createLinkUi(link);\r\n      }\r\n    } else if (change.changeType === 'remove') {\r\n      if (settings.renderLinks) {\r\n        removeLinkUi(link);\r\n      }\r\n    } else if (change.changeType === 'update') {\r\n      throw 'Update type is not implemented. TODO: Implement me!';\r\n    }\r\n  }\r\n\r\n  function onGraphChanged(changes) {\r\n    var i, change;\r\n    for (i = 0; i < changes.length; i += 1) {\r\n      change = changes[i];\r\n      if (change.node) {\r\n        processNodeChange(change);\r\n      } else if (change.link) {\r\n        processLinkChange(change);\r\n      }\r\n    }\r\n\r\n    resetStable();\r\n  }\r\n\r\n  function onWindowResized() {\r\n    updateCenter();\r\n    onRenderFrame();\r\n  }\r\n\r\n  function releaseContainerDragManager() {\r\n    if (containerDrag) {\r\n      containerDrag.release();\r\n      containerDrag = null;\r\n    }\r\n  }\r\n\r\n  function releaseGraphEvents() {\r\n    graph.off('changed', onGraphChanged);\r\n  }\r\n\r\n  function scale(out, scrollPoint) {\r\n    if (!scrollPoint) {\r\n      var containerSize = getDimension(container);\r\n      scrollPoint = {\r\n        x: containerSize.width / 2,\r\n        y: containerSize.height / 2\r\n      };\r\n    }\r\n    var scaleFactor = Math.pow(1 + 0.4, out ? -0.2 : 0.2);\r\n    transform.scale = graphics.scale(scaleFactor, scrollPoint);\r\n\r\n    renderGraph();\r\n    publicEvents.fire('scale', transform.scale);\r\n\r\n    return transform.scale;\r\n  }\r\n\r\n  function listenToEvents() {\r\n    windowEvents.on('resize', onWindowResized);\r\n\r\n    releaseContainerDragManager();\r\n    if (isInteractive('drag')) {\r\n      containerDrag = dragndrop(container);\r\n      containerDrag.onDrag(function(e, offset) {\r\n        graphics.translateRel(offset.x, offset.y);\r\n\r\n        renderGraph();\r\n      });\r\n    }\r\n\r\n    if (isInteractive('scroll')) {\r\n      if (!containerDrag) {\r\n        containerDrag = dragndrop(container);\r\n      }\r\n      containerDrag.onScroll(function(e, scaleOffset, scrollPoint) {\r\n        scale(scaleOffset < 0, scrollPoint);\r\n      });\r\n    }\r\n\r\n    graph.forEachNode(listenNodeEvents);\r\n\r\n    releaseGraphEvents();\r\n    graph.on('changed', onGraphChanged);\r\n  }\r\n\r\n  function stopListenToEvents() {\r\n    rendererInitialized = false;\r\n    releaseGraphEvents();\r\n    releaseContainerDragManager();\r\n    windowEvents.off('resize', onWindowResized);\r\n    publicEvents.off();\r\n    animationTimer.stop();\r\n\r\n    graph.forEachLink(function(link) {\r\n      if (settings.renderLinks) {\r\n        removeLinkUi(link);\r\n      }\r\n    });\r\n\r\n    graph.forEachNode(function(node) {\r\n      releaseNodeEvents(node);\r\n      removeNodeUi(node);\r\n    });\r\n\r\n    layout.dispose();\r\n    releaseDom();\r\n  }\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/windowEvents.js":"var nullEvents = require('./nullEvents.js');\n\nmodule.exports = createDocumentEvents();\n\nfunction createDocumentEvents() {\n  if (typeof window === 'undefined') {\n    return nullEvents;\n  }\n\n  return {\n    on: on,\n    off: off\n  };\n}\n\nfunction on(eventName, handler) {\n  window.addEventListener(eventName, handler);\n}\n\nfunction off(eventName, handler) {\n  window.removeEventListener(eventName, handler);\n}\n\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/gulpfile.js":"var gulp = require('gulp');\nvar gutil = require('gulp-util');\nvar buffer = require('vinyl-buffer');\nvar source = require('vinyl-source-stream');\n\nvar uglify = require('gulp-uglify');\nvar rename = require('gulp-rename');\nvar del = require('del');\nvar run = require('gulp-run');\n\ngulp.task('clean', clean);\ngulp.task('build', build);\ngulp.task('test', test);\ngulp.task('release', ['clean', 'build'], test);\ngulp.task('default', watch);\n\nfunction watch() {\n  gulp.watch('src/**/*.js', ['build']);\n}\n\nfunction clean(cb) {\n  del(['dist'], cb);\n}\n\nfunction test() {\n  new run.Command('npm test').exec();\n}\n\nfunction build() {\n  var bundler = require('browserify')('./src/viva.js', {\n    standalone: 'Viva'\n  });\n  var bundle = bundler.bundle()\n    .on('error', showError);\n\n  bundle.pipe(source('vivagraph.js'))\n    .pipe(buffer())\n    .pipe(gulp.dest('./dist/'))\n    .pipe(rename('vivagraph.min.js'))\n    .pipe(uglify())\n    .pipe(gulp.dest('./dist/'));\n\n  function showError(err) {\n    gutil.log(gutil.colors.red('Failed to browserify'), gutil.colors.yellow(err.message));\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/src/Utils/intersectRect.js":"var intersect = require('gintersect');\n\nmodule.exports = intersectRect;\n\nfunction intersectRect(left, top, right, bottom, x1, y1, x2, y2) {\n  return intersect(left, top, left, bottom, x1, y1, x2, y2) ||\n    intersect(left, bottom, right, bottom, x1, y1, x2, y2) ||\n    intersect(right, bottom, right, top, x1, y1, x2, y2) ||\n    intersect(right, top, left, top, x1, y1, x2, y2);\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/demos/other/d3layout/index.js":"var graphGenerator = Viva.Graph.generator();\nvar graph = graphGenerator.grid(20, 20);\n\nvar layout = d3Force(graph, {\n  springLength : 20,\n  springCoeff : 1,\n  gravity: -30,\n  springIterations: 10\n});\n\nvar graphics = Viva.Graph.View.webglGraphics();\n\nvar renderer = Viva.Graph.View.renderer(graph, {\n    layout: layout,\n    graphics: graphics,\n    renderLinks: true,\n    prerender: true\n});\n\nrenderer.run();\n\n// TODO: extract into module\nfunction d3Force(graph, options) {\n  // todo: check input\n  var nodes = [], links = [];\n  var nodeIdToIdx = Object.create(null);\n  var linkIdToD3Link = Object.create(null);\n\n  graph.forEachNode(function(n) {\n    var index = nodes.length;\n    nodeIdToIdx[n.id] = index;\n    var node = {\n      index: index\n    }\n    nodes.push(node);\n  });\n\n  graph.forEachLink(function(l) {\n    var source = nodeIdToIdx[l.fromId];\n    var target = nodeIdToIdx[l.toId];\n\n    var index = links.length;\n    var link = {source: source, target: target, index: index}\n    links.push(link);\n    linkIdToD3Link[l.id] = link;\n  });\n\n  var simulation = d3.forceSimulation(nodes)\n      .force(\"charge\", d3.forceManyBody().strength(options.gravity))\n      .force(\"link\", d3.forceLink(links)\n        .strength(options.springCoeff)\n        .distance(options.springLength)\n        .iterations(options.springIterations)\n      );\n\n  simulation.stop();\n\n  return {\n    step: function() {\n      simulation.tick();\n    },\n\n    getNodePosition: getNodePosition,\n\n    getLinkPosition: function(linkId) {\n      var link = linkIdToD3Link[linkId];\n      return {\n        from: link.source,\n        to: link.target\n      };\n    },\n\n    getGraphRect: function() {\n      var minX = Number.POSITIVE_INFINITY;\n      var minY = Number.POSITIVE_INFINITY;\n      var maxX = Number.NEGATIVE_INFINITY;\n      var maxY = Number.NEGATIVE_INFINITY;\n\n      nodes.forEach(function(node) {\n        if (node.x < minX) minX = node.x;\n        if (node.x > maxX) maxX = node.x;\n\n        if (node.y < minY) minY = node.y;\n        if (node.y > maxY) maxY = node.y;\n      })\n\n      return {\n        x1: minX,\n        x2: maxX,\n        y1: minY,\n        y2: maxY\n      }\n    },\n\n    isNodePinned: function() {\n      // TODO: implement\n      return false;\n    },\n\n    pinNode: function() {\n      // TODO: implement me\n    },\n\n    dispose: function() {\n    },\n\n    setNodePosition: function(nodeId, x, y) {\n      var pos = getNodePosition(nodeId);\n      pos.x = x;\n      pos.y = y;\n    }\n  }\n\n  function getNodePosition(nodeId) {\n      return nodes[nodeIdToIdx[nodeId]];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/demos/other/input-override/index.js":"// let's just rend all possible graphs on this page:\nvar generator = Viva.Graph.generator();\nvar graphNames = Object.keys(generator);\n\nfor (var i = 0; i < graphNames.length; ++i) {\n  renderGraph(graphNames[i]);\n}\n\nfunction renderGraph(name) {\n  var graph = generateGraphByName(name);\n  var layout = Viva.Graph.Layout.forceDirected(graph, {\n    springLength: 30,\n    springCoeff: 0.0008,\n    dragCoeff: 0.01,\n    gravity: -1.2,\n    theta: 1\n  });\n\n  var graphics = Viva.Graph.View.webglGraphics();\n  var renderer = Viva.Graph.View.renderer(graph, {\n    // This prevents vivagraph from handling scrolling, but will let user interact\n    // with individual nodes:\n    interactive: 'nodes',\n    // if you want to completely disable interaction, set `interactive` to false.\n    // interactive: false,\n    layout: layout,\n    graphics: graphics,\n    container: createContainer()\n  });\n\n  renderer.run();\n}\n\nfunction createContainer() {\n  var container = document.createElement('div');\n  container.className = 'graph-container';\n  document.body.appendChild(container);\n  return container;\n}\n\n// you can safely ignore this function for the purpose of this demo. It just\n// generates a random graph an duses custom nodes/links count based on generator\n// name.\nfunction generateGraphByName(name) {\n  if (name === 'wattsStrogatz') {\n    // wattsStrogatz has different default arguments, let's respect it:\n    return generator.wattsStrogatz(20, 4, 0.02);\n  } else if (name === 'completeBipartite') {\n    // it's more stable this way:\n    return generator.completeBipartite(3, 3);\n  }\n  return generator[name](5, 5, 5);\n}\n\n","/home/travis/build/npmtest/node-npmtest-vivagraphjs/node_modules/vivagraphjs/demos/other/remove-graph/index.js":"/**\n * This demo shows how to dispose renderer and create a new one.\n */\nfunction removeGraph() {\n  if (!window.renderer) {\n    return; // already removed\n  }\n  window.renderer.dispose(); // remove the graph\n  window.renderer = null;\n}\n\nfunction createNewGraph() {\n  removeGraph();\n  // just a random size for a grid graph [1, 9):\n  var n = Math.random() * 10|0 + 1;\n  var m = Math.random() * 10|0 + 1;\n  var graph = Viva.Graph.generator().grid(n, m);\n\n  window.renderer = Viva.Graph.View.renderer(graph, {\n      layout : createPhysicsLayout(graph)\n  });\n  window.renderer.run();\n}\n\nfunction createPhysicsLayout(graph) {\n  return Viva.Graph.Layout.forceDirected(graph, {\n      springLength : 10,\n      springCoeff : 0.0005,\n      dragCoeff : 0.02,\n      gravity : -1.2\n  });\n}\n"}